// line_handlers.cpp
#include "line_handlers.h"
#include <cstdio>
#include <cstring>
#include <algorithm>

// 如果你有统一的日志宏，直接用你的；这里给个兜底
#ifndef LOGE
#define LOGE(fmt, ...) std::fprintf(stderr, "[E] " fmt "\n", ##__VA_ARGS__)
#endif

#ifndef LOGD
#define LOGD(fmt, ...) std::fprintf(stdout, "[D] " fmt "\n", ##__VA_ARGS__)
#endif

static inline bool is_edge_trigger(TriggerActive a) {
    return (a == RisingEdge) || (a == FallingEdge);
}
static inline bool is_level_trigger(TriggerActive a) {
    return (a == LevelHigh) || (a == LevelLow);
}

// 拉取当前所有 Line 配置
static bool fetch_all_lines(std::vector<LineConfig>& lines) {
    lines.resize(LINE_EVENT_MAX_NUM);
    int cnt = 0;
    if (LineGetParam("AllLineConfig", lines.data(), LINE_EVENT_MAX_NUM, &cnt) != 0) {
        return false;
    }
    lines.resize(std::min(cnt, LINE_EVENT_MAX_NUM));
    return true;
}

// 规则校验：若系统存在编码器线，则所有触发线必须是“沿触发”
static int validate_encoder_vs_trigger_levels(const std::vector<LineConfig>& lines) {
    bool has_encoder = false;
    for (const auto& l : lines) {
        if (l.type == LT_ENCODER) { has_encoder = true; break; }
    }
    if (!has_encoder) return 0;

    for (size_t i = 0; i < lines.size(); ++i) {
        const auto& l = lines[i];
        if (l.type == LT_TRIGGER && is_level_trigger(l.active)) {
            LOGE("编码器只能用于沿触发模式：检测到 Line%zu 为电平触发（LevelHigh/LevelLow），与编码器冲突。", i);
            return E_ENCODER_FAILED;
        }
    }
    return 0;
}

// 在“将第 line_idx 路设置为编码器”之前的快速校验：
// 若当前存在任一触发线为电平触发 -> 禁止
static int validate_when_setting_encoder(int line_idx, const std::vector<LineConfig>& lines) {
    (void)line_idx; // 当前仅需全局检查
    for (size_t i = 0; i < lines.size(); ++i) {
        const auto& l = lines[i];
        if (l.type == LT_TRIGGER && is_level_trigger(l.active)) {
            LOGE("编码器只能用于沿触发模式：检测到 Line%zu 为电平触发，不能再把其它线路设置为编码器。", i);
            return E_ENCODER_FAILED;
        }
    }
    return 0;
}

// —— 通用的“模式设置”处理 ——
// buf: *(unsigned int*)buf 为目标模式（和你现有协议保持一致）
//
// 逻辑：
// 1) 若目标模式 == LT_ENCODER：validate_when_setting_encoder（拦截“先电平触发后选编码器”的场景）
// 2) 其余模式无需与编码器做互斥校验（规则只在“存在编码器”时约束触发线必须为沿）
//
int LineMode_handler_common(int line_idx, struct gev_register* reg, char* buf, int size) {
    HIK_UNUSED(size);
    return_if_nullptr();

    unsigned int mode = *(unsigned int*)buf;
    std::vector<LineConfig> lines;
    if (!fetch_all_lines(lines)) {
        LOGE("获取 AllLineConfig 失败");
        return -1;
    }
    if (line_idx < 0 || line_idx >= (int)lines.size()) {
        LOGE("line_idx 越界: %d", line_idx);
        return -1;
    }

    if (mode == (unsigned)LT_ENCODER) {
        // 目标改成编码器：不允许系统里存在“电平触发”的触发线
        int rc = validate_when_setting_encoder(line_idx, lines);
        if (rc != 0) return rc;
    }

    // 可选：如果目标模式不是触发，给个默认沿触发（与原有逻辑一致的保护）
    // 如果你们有 device_configs->LineXActivation 的直接访问，这里可以进行设置。
    // 否则由上层保存时写默认值即可。
    // if (mode != (unsigned)LT_TRIGGER) { ... 默认 RisingEdge ... }

    return 0;
}

// —— 通用的“激活设置（沿/电平）”处理 ——
// buf: *(unsigned int*)buf 为目标 active（RisingEdge/...）
//
// 逻辑：
// 若该路当前是 LT_TRIGGER 且目标 active 为电平（LevelHigh/LevelLow），而系统存在任一路为编码器 -> 禁止
//
int LineActivation_handler_common(int line_idx, struct gev_register* reg, char* buf, int size) {
    HIK_UNUSED(size);
    return_if_nullptr();

    unsigned int active = *(unsigned int*)buf;

    std::vector<LineConfig> lines;
    if (!fetch_all_lines(lines)) {
        LOGE("获取 AllLineConfig 失败");
        return -1;
    }
    if (line_idx < 0 || line_idx >= (int)lines.size()) {
        LOGE("line_idx 越界: %d", line_idx);
        return -1;
    }

    const LineConfig& cur = lines[line_idx];
    if (cur.type == LT_TRIGGER && is_level_trigger(static_cast<TriggerActive>(active))) {
        // 只要系统内存在编码器线，就不允许该触发线设置为电平
        for (size_t i = 0; i < lines.size(); ++i) {
            if (lines[i].type == LT_ENCODER) {
                LOGE("编码器只能用于沿触发模式：已存在编码器(Line%zu)，因此 Line%d 不可设置为电平触发。", i, line_idx);
                return E_ENCODER_FAILED;
            }
        }
    }
    return 0;
}

// —— 五路薄包装：保持你现有导出的符号名 ——
// Mode
int Line0Mode_handler(struct gev_register* reg, char* buf, int size) { return LineMode_handler_common(0, reg, buf, size); }
int Line1Mode_handler(struct gev_register* reg, char* buf, int size) { return LineMode_handler_common(1, reg, buf, size); }
int Line2Mode_handler(struct gev_register* reg, char* buf, int size) { return LineMode_handler_common(2, reg, buf, size); }
int Line3Mode_handler(struct gev_register* reg, char* buf, int size) { return LineMode_handler_common(3, reg, buf, size); }
int Line4Mode_handler(struct gev_register* reg, char* buf, int size) { return LineMode_handler_common(4, reg, buf, size); }

// Activation
int Line0Activation_handler(struct gev_register* reg, char* buf, int size) { return LineActivation_handler_common(0, reg, buf, size); }
int Line1Activation_handler(struct gev_register* reg, char* buf, int size) { return LineActivation_handler_common(1, reg, buf, size); }
int Line2Activation_handler(struct gev_register* reg, char* buf, int size) { return LineActivation_handler_common(2, reg, buf, size); }
int Line3Activation_handler(struct gev_register* reg, char* buf, int size) { return LineActivation_handler_common(3, reg, buf, size); }
int Line4Activation_handler(struct gev_register* reg, char* buf, int size) { return LineActivation_handler_common(4, reg, buf, size); }