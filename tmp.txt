#pragma once

#include "config_global.h"
#include "config_callbacks.h" // Note: This was 'config_callback.h' in your snippet, check filename
#include "oconfig.h"
#include "types_parser.h" // Include the new parser header

#include <vector> // For std::vector
#include <string> // For std::string
#include <functional> // For std::function

class ConfigManager
{
public:
    static ConfigManager &Instance()
    {
        static ConfigManager instance;
        return instance;
    }

    int Read(const char *filename);
    int DispatchOption(const std::string &key, const std::string &value);
    int Search(const std::string &key);
    int Register(const std::string &type,
                 std::function<int(const std::string &, const std::string &)> cb,
                 const std::vector<std::string> &keys,
                 plugin_ctx_t ctx); // Assuming plugin_ctx_t is defined somewhere
    int Unregister(const std::string &type);
    int RegisterComplex(const std::string &type,
                        std::function<int(OConfigItem &)> cb,
                        plugin_ctx_t ctx);
    int UnregisterComplex(const std::string &type);
    void SetGlobalOption(const std::string &key, const std::string &value);
    std::string GetGlobalOption(const std::string &key);
    double GetGlobalOptionTime(const std::string &key, double def);
    double GetDefaultInterval();

    // Method to get the parsed datasets (vector)
    const std::vector<data_set_t>& GetTypeDataSets() const;

    // New method to get a specific data_set_t by its type name
    // Returns nullptr if not found.
    const data_set_t* GetDataSetByName(const std::string& type_name) const;

    // C-style lookup similar to c_avl_get, returns 0 on success, -1 on failure
    // `out_ds` will point to the data_set_t if found.
    int GetDataSetByName(const char* type_name, const data_set_t** out_ds) const;


    // 删除拷贝构造函数和赋值运算符
    ConfigManager(const ConfigManager &) = delete;
    ConfigManager &operator=(const ConfigManager &) = delete;

private:
    ConfigManager();
    ~ConfigManager(); // Make sure to call TypesDbParser::free_datasets in destructor

    void InitGlobalOptions();
    void InitValueMapper();

    int DispatchValuePluginDir(OConfigItem &ci);
    int DispatchLoadPlugin(OConfigItem &ci);
    int DispatchBlockPlugin(OConfigItem &ci);
    int FcConfigure(OConfigItem &ci);
    int DispatchGlobalOption(OConfigItem &ci);
    int DispatchBlock(OConfigItem &ci);
    int DispatchValue(OConfigItem &ci);

private:
    CfGlobalConfig global_config_;
    CfCallbackRegistry callback_registry_;
    CfComplexCallbackRegistry complex_registry_;
    CfValueMapper value_mapper_;
    std::vector<data_set_t> type_datasets_; 
    // For thread safety if type_datasets_ can be modified concurrently after init:
    // mutable std::mutex type_datasets_mutex_; 
};
