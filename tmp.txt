#include <string>
#include <vector>
#include <memory>
#include <sstream> // 需要包含，用于 std::ostringstream
#include <iomanip> // 需要包含，用于 std::setw, std::setfill, std::fixed, std::setprecision
#include <cstdio>  // 需要包含，用于 sscanf

// CFormatter 基类 (假设已定义或如你提供)
class CFormatter
{
protected:
	std::string formatStr; // 用于存储格式字符串
	std::string separator; // 用于存储分隔符

public:
	CFormatter(const std::string &fmt, const std::string &sep) : formatStr(fmt), separator(sep) {}

	virtual ~CFormatter() {}

	virtual std::string format() = 0;

	const std::string &getSeparator() const { return separator; }
};

// int 类型的 CFormatter
class IntFormatter : public CFormatter
{
	int value;

public:
	IntFormatter(int v, const std::string &fmt, const std::string &sep) : CFormatter(fmt, sep), value(v) {}

	std::string format() override
	{
		int width = 0;
		// 从 "%10d" 这样的格式字符串中提取宽度
		if (sscanf(formatStr.c_str(), "%%%dd", &width) == 1) {
            // sscanf 成功并且读取了 width
        } else {
            // 如果 formatStr 不是预期的格式，则处理错误或设置默认宽度
            // 例如，如果 sscanf 失败，width 将保持为 0
            // 你也可以选择抛出异常或记录错误
        }

		std::ostringstream oss;
		oss << std::setw(width) << std::setfill('0') << value; // 添加了 std::setfill('0')
		return oss.str();
	}
};

// float 类型的 CFormatter
class FloatFormatter : public CFormatter
{
	float value;

public:
	FloatFormatter(float v, const std::string &fmt, const std::string &sep) : CFormatter(fmt, sep), value(v) {}

	std::string format() override
	{
		int width = 0, precision = 0;
        // 从 "%10.3f" 这样的格式字符串中提取宽度和精度
		if (sscanf(formatStr.c_str(), "%%%d.%df", &width, &precision) == 2) {
            // sscanf 成功并且读取了 width 和 precision
        } else if (sscanf(formatStr.c_str(), "%%%df", &width) == 1) { // 对应 "%10f" 这样的情况
            // 只指定了宽度，精度可以默认为0或标准浮点数精度（通常是6）
        }
        else {
            // 处理错误或设置默认的 width/precision
        }

		std::ostringstream oss;
		// 添加了 std::setfill('0')
		oss << std::fixed << std::setw(width) << std::setfill('0') << std::setprecision(precision) << value;
		return oss.str();
	}
};

// 字符串类型的 CFormatter (保持不变，但为了完整性包含在此)
class StringFormatter : public CFormatter
{
	std::string value;

public:
	StringFormatter(const std::string &v, const std::string &fmt, const std::string &sep) : CFormatter(fmt, sep), value(v) {}
	std::string format() override
	{
		// 字符串格式化器通常不以这种方式使用C风格格式字符串中的宽度/填充。
        // 如果需要填充，对于 std::string 将需要不同的方法。
        // 目前，它只是按照原始代码返回该值。
		return value;
	}
};

// 假设 CFormatModule 和其 FormatAndCombine 方法已定义
// 例如:
class CFormatModule {
public:
    // 'IN' 关键字不是标准 C++，通常是注释或用于文档的宏。
    // 为了标准的 C++ 语法，我将其移除。
    std::string FormatAndCombine(const std::vector<std::unique_ptr<CFormatter>> &formatters)
    {
        std::string strResult;
        bool firstElement = true; // 用于控制分隔符的添加
        for (const auto &formatter : formatters)
        {
            if (!formatter) continue; // 防御性检查

            // 如果不是第一个元素，并且我们希望分隔符在元素之间
            // (注意：原始逻辑是在每个元素后添加分隔符)
            // if (!firstElement) {
            //     strResult += formatter->getSeparator(); // 或者一个通用的分隔符
            // }
            strResult += formatter->format();
            strResult += formatter->getSeparator(); // 原始逻辑：在每个元素后添加其分隔符
            // firstElement = false; // 如果分隔符在元素之间，则需要这个
        }
        // 如果你希望严格遵循原始逻辑（每个元素后都有分隔符），那么上面的循环是正确的。
        // 如果你希望分隔符仅在元素 *之间*，那么最后一个元素不应该有后缀分隔符，
        // 这需要稍微修改循环逻辑，例如：
        /*
        std::string strResult;
        for (size_t i = 0; i < formatters.size(); ++i) {
            if (formatters[i]) {
                strResult += formatters[i]->format();
                if (i < formatters.size() - 1) { // 只在非最后一个元素后添加分隔符
                    strResult += formatters[i]->getSeparator(); // 或者下一个元素的 getSeparator()，取决于设计
                } else if (!formatters[i]->getSeparator().empty()){
                    // 如果设计就是每个元素（包括最后一个）都必须有其定义的分隔符跟随，即使它是空的
                     strResult += formatters[i]->getSeparator();
                }
            }
        }
        */
        return strResult;
    }
};

// 使用示例 (可以放在你的 main 函数或测试函数中)
/*
#include <iostream> // 用于 std::cout

int main() {
    std::vector<std::unique_ptr<CFormatter>> formatters;

    // 示例：整数补零
    formatters.push_back(std::make_unique<IntFormatter>(42, "%5d", ",")); // 格式化为 "00042"
    // 示例：浮点数补零
    formatters.push_back(std::make_unique<FloatFormatter>(3.14159f, "%08.3f", ";")); // 格式化为 "0003.142"
    // 字符串类型
    formatters.push_back(std::make_unique<StringFormatter>("test", "%s", "|"));

    CFormatModule module;
    std::string result = module.FormatAndCombine(formatters);

    // 根据原始的 FormatAndCombine 逻辑，结果会是: "00042,0003.142;test|"
    // (每个格式化后的字符串都带上了它自己的分隔符)
    std::cout << "Formatted string: " << result << std::endl;

    return 0;
}
*/
