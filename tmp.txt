/*
 * A simplified parser for Collectd-style config files using:
 *
 *   # comment
 *   key value1 value2 ...
 *   <BlockName arg1 arg2 ...>
 *       ...
 *   </BlockName>
 *
 * The result is stored in an OConfigItem tree (as defined in your oconfig.h).
 *
 * Build with: g++ -std=c++14 -I. -c oconfig.cpp
 */

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include <cerrno>
#include <string>
#include <vector>
#include <memory>
#include <sstream>
#include <iostream>

#include "oconfig.h"

//---------------------------------------------------------
// 工具函数：去掉字符串首尾的空白字符
//---------------------------------------------------------
static std::string trim(const std::string &s)
{
    size_t start = 0;
    while (start < s.size() && std::isspace(static_cast<unsigned char>(s[start])))
        ++start;

    if (start == s.size())
        return "";

    size_t end = s.size() - 1;
    while (end > start && std::isspace(static_cast<unsigned char>(s[end])))
        --end;

    return s.substr(start, end - start + 1);
}

//---------------------------------------------------------
// 工具函数：若字符串带引号，去掉最外层引号
//---------------------------------------------------------
static std::string stripQuotes(const std::string &s)
{
    if (s.size() >= 2) {
        if ((s.front() == '"'  && s.back() == '"') ||
            (s.front() == '\'' && s.back() == '\''))
        {
            return s.substr(1, s.size() - 2);
        }
    }
    return s;
}

//---------------------------------------------------------
// 解析一行：将其按空格分割成 tokens（支持简单的 "..."）
// - 若行中包含带引号的参数，会保留它作为一个整体再 stripQuotes
//---------------------------------------------------------
static std::vector<std::string> tokenizeLine(const std::string &line)
{
    std::vector<std::string> tokens;
    // 这里我们做一个最简易的 "按空格分割 + 引号 合并" 逻辑
    // 若需要更复杂的转义，可加额外解析
    bool inQuotes = false;
    char quoteChar = 0;
    std::ostringstream current;
    
    for (size_t i = 0; i < line.size(); ++i) {
        char c = line[i];
        if (!inQuotes) {
            // 如果还没进入引号
            if ((c == '"' || c == '\'') && !std::isspace(static_cast<unsigned char>(c))) {
                inQuotes = true;
                quoteChar = c;
                current << c;  // 保留
            }
            else if (std::isspace(static_cast<unsigned char>(c))) {
                // token 分割
                if (current.tellp() > 0) {
                    tokens.push_back(current.str());
                    current.str("");
                    current.clear();
                }
            } 
            else {
                current << c;
            }
        }
        else {
            // 在引号里
            current << c;
            if (c == quoteChar) {
                // 引号关闭
                inQuotes = false;
            }
        }
    }

    if (current.tellp() > 0) {
        tokens.push_back(current.str());
    }

    // 去除外层引号
    for (auto &t : tokens) {
        t = trim(t);
        t = stripQuotes(t);
    }
    return tokens;
}

//---------------------------------------------------------
// 解析配置的核心递归：
// - readLine 循环
// - 如果遇到 <BlockName ...> => 新子节点
// - 如果遇到 </BlockName> => return
// - 否则解析 key + values
//---------------------------------------------------------
static int parseBlock(FILE *fh, OConfigItem &parent, const std::string &blockName, bool isRoot, int &lineNum)
{
    // blockName 对 <BlockName> 是仅供提示
    // isRoot 表示是否顶层 parse
    char buf[1024];

    while (true) {
        if (!std::fgets(buf, sizeof(buf), fh)) {
            // EOF
            return 0; 
        }
        lineNum++;
        std::string line = trim(buf);
        if (line.empty()) {
            continue; // skip blank
        }
        if (line[0] == '#') {
            continue; // skip comment
        }
        // 若检测到 block 结束
        if (line.size() >= 2 && line[0] == '<' && line[1] == '/') {
            // 例如 </Plugin>
            // 提取 block 名称
            // 形如 </Plugin logfile> 也可能出现，但 collectd 常见是 </Plugin>
            // 我们做最小假设： `</BlockName>`
            // 直接返回
            return 0;
        }
        // 若检测到 block 开始
        if (line[0] == '<' && line[1] != '/') {
            // 形如 `<Plugin logfile>`
            // 先去除首尾 < >
            // 解析 tokens
            if (line.back() == '>') {
                line = line.substr(1, line.size() - 2); // 去掉 < >
                line = trim(line);
            } else {
                // 行末没 '>'，简单处理：把最后一个 '>'忽略之类
                // 这里简化
                size_t pos = line.rfind('>');
                if (pos != std::string::npos && pos > 0) {
                    line = line.substr(1, pos - 1); 
                }
            }
            std::vector<std::string> tokens = tokenizeLine(line);
            if (tokens.empty()) {
                // 语法错误
                std::cerr << "Parse error at line " << lineNum 
                          << ": empty block start\n";
                return -1;
            }
            // 第一个是 blockName
            std::string blockKey = tokens[0];
            // 创建 <blockKey> 子节点
            OConfigItem *child = parent.addChild(blockKey);
            // 把剩余 tokens 存成 child 的 values (类似 <Plugin "logfile"> => Key="Plugin", Value="logfile")
            for (size_t i = 1; i < tokens.size(); ++i) {
                child->addValue(OConfigValue(tokens[i]));
            }
            // 递归解析子块
            int status = parseBlock(fh, *child, blockKey, false, lineNum);
            if (status != 0) {
                return status;
            }
            // 继续下一个行
            continue;
        }

        // 否则就是普通行: 形如 `Key value1 value2 ...`
        std::vector<std::string> tokens = tokenizeLine(line);
        if (!tokens.empty()) {
            std::string key = tokens[0];
            OConfigItem *child = parent.addChild(key);
            // 其余tokens存为值
            for (size_t i = 1; i < tokens.size(); ++i) {
                child->addValue(OConfigValue(tokens[i]));
            }
        }
    } // while

    return 0;
}

//---------------------------------------------------------
// 对外：解析文件
//---------------------------------------------------------
static int oconfig_parse_file_internal(const char *filename, OConfigItem &root)
{
    FILE *fh = std::fopen(filename, "r");
    if (!fh) {
        std::cerr << "[Error] Cannot open file: " << filename 
                  << " (" << std::strerror(errno) << ")\n";
        return -1;
    }
    int lineNum = 0;
    int status = parseBlock(fh, root, "root", true, lineNum);
    std::fclose(fh);
    return status;
}

//---------------------------------------------------------
// 对外：解析字符串
//---------------------------------------------------------
static int oconfig_parse_string_internal(const char *buffer, OConfigItem &root)
{
    if (!buffer) {
        std::cerr << "[Error] parse_string: buffer is null\n";
        return -1;
    }
    // 用临时文件方式写入
    FILE *fh = std::tmpfile();
    if (!fh) {
        std::cerr << "[Error] tmpfile() failed\n";
        return -1;
    }
    std::fputs(buffer, fh);
    std::fflush(fh);
    std::fseek(fh, 0, SEEK_SET);

    int lineNum = 0;
    int status = parseBlock(fh, root, "root", true, lineNum);

    std::fclose(fh);
    return status;
}

//---------------------------------------------------------
// 提供类似 collectd oconfig.c 的对外接口
//---------------------------------------------------------
int oconfig_parse_file_cxx14(const char *filename, OConfigItem *root)
{
    if (!root) return -1;
    return oconfig_parse_file_internal(filename, *root);
}

int oconfig_parse_string_cxx14(const char *buffer, OConfigItem *root)
{
    if (!root) return -1;
    return oconfig_parse_string_internal(buffer, *root);
}

//---------------------------------------------------------
// 下面是一些可能的辅助函数 (clone, free, etc.) 
// 若你在别处已有实现，可不重复
//---------------------------------------------------------
OConfigItem* oconfig_new_item_cxx14(const char *key)
{
    if (!key) return nullptr;
    return new OConfigItem(std::string(key));
}

void oconfig_free_cxx14(OConfigItem *item)
{
    delete item; // OConfigItem 的 unique_ptr children 会自动递归释放
}

#include <stdexcept>

OConfigItem* oconfig_clone_cxx14(const OConfigItem *src)
{
    if (!src) return nullptr;
    // 简单写一个深拷贝
    OConfigItem *dest = new OConfigItem(src->key);
    dest->values = src->values;
    for (auto &childPtr : src->children) {
        OConfigItem *childClone = oconfig_clone_cxx14(childPtr.get());
        childClone->parent = dest;
        dest->children.emplace_back(childClone);
    }
    return dest;
}

void oconfig_set_string_cxx14(OConfigItem *item, const char *str)
{
    if (!item || !str) return;
    item->values.clear();
    item->addValue(OConfigValue(std::string(str)));
}

void oconfig_add_string_cxx14(OConfigItem *item, const char *str)
{
    if (!item || !str) return;
    item->addValue(OConfigValue(std::string(str)));
}

void oconfig_set_number_cxx14(OConfigItem *item, double val)
{
    if (!item) return;
    item->values.clear();
    item->addValue(OConfigValue(val));
}

void oconfig_add_number_cxx14(OConfigItem *item, double val)
{
    if (!item) return;
    item->addValue(OConfigValue(val));
}

void oconfig_set_boolean_cxx14(OConfigItem *item, bool val)
{
    if (!item) return;
    item->values.clear();
    item->addValue(OConfigValue(val));
}

void oconfig_add_boolean_cxx14(OConfigItem *item, bool val)
{
    if (!item) return;
    item->addValue(OConfigValue(val));
}

void oconfig_clone_values_cxx14(OConfigItem *dest, const OConfigItem *src)
{
    if (!dest || !src) return;
    dest->values = src->values;
}