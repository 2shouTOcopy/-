#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <errno.h>
#include <unistd.h>
#include <sys/stat.h>
#include <fcntl.h>

/* 去掉行尾的 \r \n */
static void trim_eol(char* s)
{
    if (s == NULL) return;
    size_t n = strlen(s);
    while (n > 0 && (s[n - 1] == '\n' || s[n - 1] == '\r')) {
        s[n - 1] = '\0';
        --n;
    }
}

/* 跳过前导空格 */
static const char* skip_spaces(const char* s)
{
    while (s && *s && isspace((unsigned char)*s)) s++;
    return s;
}

/*
 * 判断一行是否是 key=... （允许：前导空格、key后空格、=左右空格）
 * 命中返回 1，否则 0
 */
static int match_key_line(const char* line, const char* key)
{
    if (!line || !key) return 0;

    const char* p = skip_spaces(line);

    /* 注释行直接跳过 */
    if (*p == '#' || *p == ';' || *p == '\0') return 0;

    size_t klen = strlen(key);
    if (strncmp(p, key, klen) != 0) return 0;

    p += klen;
    p = skip_spaces(p);

    return (*p == '=');
}

/**
 * @brief 修改/写入配置文件的 key=value
 * @param path 文件路径，如 "/mnt/cfg/psh.conf"
 * @param key  key，如 "PSH_TMOUT"（不需要带 '='）
 * @param value value，如 "0"
 * @return 成功返回0，失败返回-1
 */
int32_t utils_update_kv_file(const char* path, const char* key, const char* value)
{
    if (path == NULL || key == NULL || value == NULL) {
        LOGE("utils_update_kv_file invalid param\n");
        return -1;
    }

    /* 如果 key 传进来是 "PSH_TMOUT=" 这种，容错处理一下 */
    char key_buf[128] = {0};
    snprintf(key_buf, sizeof(key_buf), "%s", key);
    size_t key_len = strlen(key_buf);
    if (key_len > 0 && key_buf[key_len - 1] == '=') {
        key_buf[key_len - 1] = '\0';
    }

    /* 记录原文件权限/属主（若存在） */
    struct stat st;
    int has_old = (stat(path, &st) == 0);

    FILE* in = fopen(path, "r"); /* 文件不存在也没关系 */

    /* 临时文件：同目录下 mkstemp，避免并发冲突 */
    char tmp_path[512] = {0};
    snprintf(tmp_path, sizeof(tmp_path), "%s.tmpXXXXXX", path);

    int tmp_fd = mkstemp(tmp_path);
    if (tmp_fd < 0) {
        LOGE("mkstemp failed %s errno=%d\n", tmp_path, errno);
        if (in) fclose(in);
        return -1;
    }

    FILE* out = fdopen(tmp_fd, "w");
    if (out == NULL) {
        LOGE("fdopen failed errno=%d\n", errno);
        close(tmp_fd);
        unlink(tmp_path);
        if (in) fclose(in);
        return -1;
    }

    int replaced = 0;
    char line[1024];

    if (in) {
        while (fgets(line, sizeof(line), in) != NULL) {
            trim_eol(line);

            if (!replaced && match_key_line(line, key_buf)) {
                fprintf(out, "%s=%s\n", key_buf, value);
                replaced = 1;
            } else {
                fprintf(out, "%s\n", line);
            }
        }
        fclose(in);
        in = NULL;
    }

    if (!replaced) {
        fprintf(out, "%s=%s\n", key_buf, value);
    }

    fflush(out);

    /* 尽量把数据刷到盘（对 flash/overlay 也更稳一点） */
    int fd = fileno(out);
    if (fd >= 0) {
        (void)fsync(fd);
    }

    fclose(out); /* 这里也会 close(tmp_fd) */

    /* 恢复权限/属主（若原文件存在） */
    if (has_old) {
        (void)chmod(tmp_path, st.st_mode);
        (void)chown(tmp_path, st.st_uid, st.st_gid);
    }

    /* 原子替换 */
    if (rename(tmp_path, path) != 0) {
        LOGE("rename failed %s -> %s errno=%d\n", tmp_path, path, errno);
        unlink(tmp_path);
        return -1;
    }

    LOGI("update kv ok: %s=%s in %s\n", key_buf, value, path);
    return 0;
}