// collectd.cpp (简化版)

#include "collectd.h"
#include "plugin.h"

// 全局命令行配置结构，增加 flush 参数
struct CmdConfig {
  bool daemonize = true;
  bool flush_mode = false;
  std::string flush_plugin; // 空表示全局
  // … 其他字段 …
};

// 遍历所有已注册的 read 回调，手动执行
static void manual_read() {
  // read_list 存储了所有 read 回调 (参见 plugin.c 中 read_list)
  extern llist_t *read_list;
  for (llentry_t *le = llist_head(read_list); le; le = le->next) {
    auto *rf = reinterpret_cast<read_func_t*>(le->value);
    if (rf->rf_type == RF_SIMPLE) {
      auto cb = reinterpret_cast<int(*)(void)>(rf->rf_callback);
      cb();
    } else {
      auto cb = reinterpret_cast<plugin_read_cb>(rf->rf_callback);
      cb(&rf->rf_udata);
    }
  }
}

// flush 线程入口：先 manual_read，再 plugin_flush
static void* do_manual_flush(void* arg) {
  const char *plugin = reinterpret_cast<const char*>(arg);
  INFO("Manual flush: reading all data…");
  manual_read();
  INFO("Manual flush: flushing plugin '%s'…", plugin ? plugin : "ALL");
  // timeout 设为 0，identifier 设为 nullptr
  plugin_flush(plugin, static_cast<cdtime_t>(0), nullptr);
  INFO("Manual flush: done.");
  return nullptr;
}

// 信号处理: SIGUSR1 全局 flush，SIGUSR2 插件级 flush
static void sig_usr1_handler(int) {
  pthread_t th; pthread_attr_t attr;
  pthread_attr_init(&attr);
  pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
  pthread_create(&th, &attr, do_manual_flush, nullptr); // 全局
  pthread_attr_destroy(&attr);
}

static void sig_usr2_handler(int) {
  // 假设我们要 flush dmesg 插件
  static const char *plugin_name = "dmesg";
  pthread_t th; pthread_attr_t attr;
  pthread_attr_init(&attr);
  pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
  pthread_create(&th, &attr, do_manual_flush,
                 const_cast<char*>(plugin_name));
  pthread_attr_destroy(&attr);
}

// 主函数中命令行解析示例
int main(int argc, char **argv) {
  CmdConfig cfg = parse_cmdline(argc, argv);
  // 如果是 flush 模式，则只做一次 manual_flush 后退出
  if (cfg.flush_mode) {
    plugin_init_ctx();
    if (plugin_init_all() != 0)
      return EXIT_FAILURE;
    // 传入插件名或 nullptr
    do_manual_flush(
      cfg.flush_plugin.empty() ? nullptr
                               : const_cast<char*>(cfg.flush_plugin.c_str())
    );
    return EXIT_SUCCESS;
  }

  // 常规守护进程模式：注册信号
  struct sigaction sa1{}, sa2{};
  sa1.sa_handler = sig_usr1_handler;
  sigaction(SIGUSR1, &sa1, nullptr);
  sa2.sa_handler = sig_usr2_handler;
  sigaction(SIGUSR2, &sa2, nullptr);

  // … 继续 init、do_loop、shutdown 等（见 collectd.c） …
}