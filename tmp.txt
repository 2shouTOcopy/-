// src/redline_wire.h
#pragma once
extern "C" {
#include "gvcp_redline.h"
}
#include <cstring>
#include <cstdint>
#include <array>

// ========== 通用小工具 ==========
static inline bool RL_CheckSize(const gvcp_packet* pkt, int need) {
    return pkt && pkt->data && pkt->size >= need;
}

// ========== 1) 交换码 Interchange ==========

enum class RL_InterDataMode : uint8_t {
    Salt_EncryptedRandom = 0,  // inter_data 里用 salt[16]，inter_data2 用 enRandomString[512]
    Reserved_PlainRandom = 1   // inter_data 里用 reserved2[16]，inter_data2 用 RandomString[16]
};

// —— Host 视图（CMD）——
struct RL_InterchangeCmdView {
    uint16_t mode = 0;
    uint16_t macHigh = 0;
    uint32_t macLow = 0;
    std::array<uint8_t,16>  userName{};
    std::array<uint8_t,896> publicKey{}; // 512 传输字节（base64？）/384 实际公钥字节——按你上层逻辑使用
};

static inline bool RL_ParseInterchangeCmd(const gvcp_packet* pkt, RL_InterchangeCmdView& out) {
    if (!RL_CheckSize(pkt, (int)sizeof(REDLINE_INTERCHANGE_CMD_T))) return false;
    REDLINE_INTERCHANGE_CMD_T raw{};
    std::memcpy(&raw, pkt->data, sizeof(raw));
    out.mode    = ntohs(raw.mode);
    out.macHigh = ntohs(raw.macHigh);
    out.macLow  = ntohl(raw.maclow);
    std::memcpy(out.userName.data(),  raw.auth_data.userName,  out.userName.size());
    std::memcpy(out.publicKey.data(), raw.auth_data.publicKey, out.publicKey.size());
    return true;
}

// —— Host 视图（ACK）——
struct RL_InterchangeAckView {
    uint32_t reserved1 = 0;
    RL_InterDataMode mode = RL_InterDataMode::Salt_EncryptedRandom;
    std::array<uint8_t,16>  salt{};            // 当 mode=Salt_EncryptedRandom 使用
    std::array<uint8_t,512> enRandomString{};  // 当 mode=Salt_EncryptedRandom 使用
    std::array<uint8_t,16>  randomString{};    // 当 mode=Reserved_PlainRandom 使用
    std::array<uint8_t,8>   devE1{};           // 必填：用随机串+盐计算的后8字节
};

static inline bool RL_WriteInterchangeAck(gvcp_packet* pkt, const RL_InterchangeAckView& v, int* size) {
    if (!pkt || !pkt->data || !size) return false;
    REDLINE_INTERCHANGE_ACK_T raw{};
    raw.reserved1 = htonl(v.reserved1);
    if (v.mode == RL_InterDataMode::Salt_EncryptedRandom) {
        std::memcpy(raw.inter_data.salt, v.salt.data(), v.salt.size());
        std::memcpy(raw.inter_data2.enRandomString, v.enRandomString.data(), v.enRandomString.size());
    } else {
        // reserved2[16] 随意占位（全0），交由上层自定；只在用明文随机串时走这条
        std::memset(raw.inter_data.reserved2, 0, sizeof(raw.inter_data.reserved2));
        std::memcpy(raw.inter_data2.RandomString, v.randomString.data(), v.randomString.size());
    }
    std::memcpy(raw.devE1, v.devE1.data(), v.devE1.size());
    std::memcpy(pkt->data, &raw, sizeof(raw));
    *size = sizeof(raw);
    return true;
}

// ========== 2) 激活 Active ==========

// —— Host 视图（CMD）——
struct RL_ActiveCmdView {
    std::array<uint8_t,16> username{};
    std::array<uint8_t,24> enPassword{}; // AES+Base64（你的上层解析）
};

static inline bool RL_ParseActiveCmd(const gvcp_packet* pkt, RL_ActiveCmdView& out) {
    if (!RL_CheckSize(pkt, (int)sizeof(REDLINE_ACTIVE_CMD_T))) return false;
    REDLINE_ACTIVE_CMD_T raw{};
    std::memcpy(&raw, pkt->data, sizeof(raw));
    std::memcpy(out.username.data(),   raw.username,   out.username.size());
    std::memcpy(out.enPassword.data(), raw.enPassword, out.enPassword.size());
    return true;
}

// —— Host 视图（ACK）——
struct RL_ActiveAckView {
    uint32_t reserved1 = 0;
    std::array<uint8_t,16> salt{};
};

static inline bool RL_WriteActiveAck(gvcp_packet* pkt, const RL_ActiveAckView& v, int* size) {
    if (!pkt || !pkt->data || !size) return false;
    REDLINE_ACTIVE_ACK_T raw{};
    raw.reserved1 = htonl(v.reserved1);
    std::memcpy(raw.salt, v.salt.data(), v.salt.size());
    std::memcpy(pkt->data, &raw, sizeof(raw));
    *size = sizeof(raw);
    return true;
}

// ========== 3) 恢复激活 Restore (SESTORE) ==========

// —— Host 视图（CMD）——
struct RL_RestoreCmdView {
    std::array<uint8_t,64> enString{};
};

static inline bool RL_ParseRestoreCmd(const gvcp_packet* pkt, RL_RestoreCmdView& out) {
    if (!RL_CheckSize(pkt, (int)sizeof(REDLINE_SESTORE_CMD_T))) return false;
    REDLINE_SESTORE_CMD_T raw{};
    std::memcpy(&raw, pkt->data, sizeof(raw));
    std::memcpy(out.enString.data(), raw.enString, out.enString.size());
    return true;
}

// —— Host 视图（ACK）——
struct RL_RestoreAckView {
    uint32_t reserved1 = 0;
};

static inline bool RL_WriteRestoreAck(gvcp_packet* pkt, const RL_RestoreAckView& v, int* size) {
    if (!pkt || !pkt->data || !size) return false;
    REDLINE_SESTORE_ACK_T raw{};
    raw.reserved1 = htonl(v.reserved1);
    std::memcpy(pkt->data, &raw, sizeof(raw));
    *size = sizeof(raw);
    return true;
}

// ========== 4) 登录 Login ==========

// —— Host 视图（CMD）——
struct RL_LoginCmdView {
    uint16_t function = 0;
    uint16_t macHigh  = 0;
    uint32_t macLow   = 0;
    std::array<uint8_t,64> enString{};
};

static inline bool RL_ParseLoginCmd(const gvcp_packet* pkt, RL_LoginCmdView& out) {
    if (!RL_CheckSize(pkt, (int)sizeof(REDLINE_LOGIN_CMD_T))) return false;
    REDLINE_LOGIN_CMD_T raw{};
    std::memcpy(&raw, pkt->data, sizeof(raw));
    out.function = ntohs(raw.Function);
    out.macHigh  = ntohs(raw.macHigh);
    out.macLow   = ntohl(raw.maclow);
    std::memcpy(out.enString.data(), raw.enString, out.enString.size());
    return true;
}

// —— Host 视图（ACK）——
struct RL_LoginAckView {
    uint16_t keepAlivePort    = 0;
    uint16_t fileAccessPort   = 0;
    uint16_t loginFailedTimes = 0;
    uint16_t remainLogTimes   = 0;
    std::array<uint8_t,8>  reserved1{};
    std::array<uint8_t,16> cookie{};
    std::array<uint8_t,8>  devEn{};
};

static inline bool RL_WriteLoginAck(gvcp_packet* pkt, const RL_LoginAckView& v, int* size) {
    if (!pkt || !pkt->data || !size) return false;
    REDLINE_LOGIN_ACK_T raw{};
    raw.keepAlivePort   = htons(v.keepAlivePort);
    raw.fileAccessPort  = htons(v.fileAccessPort);
    raw.loginFaiedTimes = htons(v.loginFailedTimes);
    raw.remainLogTimes  = htons(v.remainLogTimes);
    std::memcpy(raw.reserved1, v.reserved1.data(), v.reserved1.size());
    std::memcpy(raw.cookie,    v.cookie.data(),    v.cookie.size());
    std::memcpy(raw.devEn,     v.devEn.data(),     v.devEn.size());
    std::memcpy(pkt->data, &raw, sizeof(raw));
    *size = sizeof(raw);
    return true;
}

// ========== 5) 修改密码 ChangePwd ==========

// —— Host 视图（CMD）——
struct RL_ChangePwdCmdView {
    std::array<uint8_t,64> en1String{};   // 旧密码摘要密文
    std::array<uint8_t,24> newPassword{}; // 新密码 AES+Base64
};

static inline bool RL_ParseChangePwdCmd(const gvcp_packet* pkt, RL_ChangePwdCmdView& out) {
    if (!RL_CheckSize(pkt, (int)sizeof(REDLINE_CHANGEPWD_CMD_T))) return false;
    REDLINE_CHANGEPWD_CMD_T raw{};
    std::memcpy(&raw, pkt->data, sizeof(raw));
    std::memcpy(out.en1String.data(),  raw.en1String,  out.en1String.size());
    std::memcpy(out.newPassword.data(),raw.newPassword,out.newPassword.size());
    return true;
}

// —— Host 视图（ACK）——（结构体为空）
static inline bool RL_WriteChangePwdAck(gvcp_packet* pkt, int* size) {
    if (!pkt || !size) return false;
    // 空体：置 size = 0（或 = sizeof(REDLINE_CHANGEPWD_ACK_T)=0）
    *size = 0;
    return true;
}

// ========== 6) 获取设备状态 GetDevInfo ==========

// —— Host 视图（CMD）——
struct RL_GetDevInfoCmdView { /* 空体，无需字段 */ };

static inline bool RL_ParseGetDevInfoCmd(const gvcp_packet* pkt) {
    return RL_CheckSize(pkt, (int)sizeof(REDLINE_GETDEVINFO_CMD_T));
}

// —— Host 视图（ACK）——
struct RL_GetDevInfoAckView {
    uint32_t reserved1 = 0;
    int32_t  rsaVer    = 0;
    std::array<uint8_t,1024> encryptedString{};
};

static inline bool RL_WriteGetDevInfoAck(gvcp_packet* pkt, const RL_GetDevInfoAckView& v, int* size) {
    if (!pkt || !pkt->data || !size) return false;
    REDLINE_GETDEVINFO_ACK_T raw{};
    raw.reserved1 = htonl(v.reserved1);
    raw.rsaVer    = htonl(v.rsaVer);
    std::memcpy(raw.encryptedString, v.encryptedString.data(), v.encryptedString.size());
    std::memcpy(pkt->data, &raw, sizeof(raw));
    *size = sizeof(raw);
    return true;
}

// ========== 7) 重置密码 ResetPwd ==========

// —— Host 视图（CMD）——
struct RL_ResetPwdCmdView {
    std::array<uint8_t,64> encryptString{};
    std::array<uint8_t,32> ivString{};
};

static inline bool RL_ParseResetPwdCmd(const gvcp_packet* pkt, RL_ResetPwdCmdView& out) {
    if (!RL_CheckSize(pkt, (int)sizeof(REDLINE_RESETPWD_CMD_T))) return false;
    REDLINE_RESETPWD_CMD_T raw{};
    std::memcpy(&raw, pkt->data, sizeof(raw));
    std::memcpy(out.encryptString.data(), raw.encryptString, out.encryptString.size());
    std::memcpy(out.ivString .data(),     raw.ivString,     out.ivString.size());
    return true;
}

// —— Host 视图（ACK）——（结构体为空）
static inline bool RL_WriteResetPwdAck(gvcp_packet* pkt, int* size) {
    if (!pkt || !size) return false;
    *size = 0;
    return true;
}

// ========== 8) 升级 Upgrade ==========

// —— Host 视图（CMD）——
struct RL_UpgradeCmdView {
    uint16_t port = 0;
    std::array<uint8_t,64> encryptString{};
};

static inline bool RL_ParseUpgradeCmd(const gvcp_packet* pkt, RL_UpgradeCmdView& out) {
    if (!RL_CheckSize(pkt, (int)sizeof(REDLINE_UPGRADE_CMD_T))) return false;
    REDLINE_UPGRADE_CMD_T raw{};
    std::memcpy(&raw, pkt->data, sizeof(raw));
    out.port = ntohs(raw.port);
    std::memcpy(out.encryptString.data(), raw.encryptString, out.encryptString.size());
    return true;
}

// —— Host 视图（ACK）——
struct RL_UpgradeAckView {
    uint16_t upgPort = 0;
    uint16_t reserved = 0;
};

static inline bool RL_WriteUpgradeAck(gvcp_packet* pkt, const RL_UpgradeAckView& v, int* size) {
    if (!pkt || !pkt->data || !size) return false;
    REDLINE_UPGRADE_ACK_T raw{};
    raw.upgPort = htons(v.upgPort);
    raw.reserved = htons(v.reserved);
    std::memcpy(pkt->data, &raw, sizeof(raw));
    *size = sizeof(raw);
    return true;
}

// ========== 9) 锁定信息 LockInfo ==========

// —— Host 视图（CMD）——
struct RL_LockInfoCmdView {
    uint16_t macHigh = 0;
    uint32_t macLow  = 0;
};

static inline bool RL_ParseLockInfoCmd(const gvcp_packet* pkt, RL_LockInfoCmdView& out) {
    if (!RL_CheckSize(pkt, (int)sizeof(REDLINE_LOCK_CMD_T))) return false;
    REDLINE_LOCK_CMD_T raw{};
    std::memcpy(&raw, pkt->data, sizeof(raw));
    out.macHigh = ntohs(raw.macHigh);
    out.macLow  = ntohl(raw.macLow);
    return true;
}

// —— Host 视图（ACK）——
struct RL_LockInfoAckView {
    uint8_t  lockSts       = 0;  // 0=未锁定 1=锁定
    uint8_t  reserved1     = 0;
    uint16_t lockTime      = 0;  // 剩余锁定时间，单位秒
    uint16_t loginFailTimes= 0;  // 登录失败次数
    uint16_t remainLogTimes= 0;  // 剩余可尝试次数
    uint16_t reserved2     = 0;
    uint16_t macHigh       = 0;
    uint32_t macLow        = 0;
};

static inline bool RL_WriteLockInfoAck(gvcp_packet* pkt, const RL_LockInfoAckView& v, int* size) {
    if (!pkt || !pkt->data || !size) return false;
    REDLINE_LOCK_ACK_T raw{};
    raw.lockSts         = v.lockSts;
    raw.reserved1       = v.reserved1;
    raw.lockTime        = htons(v.lockTime);
    raw.loginFaiedTimes = htons(v.loginFailTimes);
    raw.remainLogTimes  = htons(v.remainLogTimes);
    raw.reserved2       = htons(v.reserved2);
    raw.macHigh         = htons(v.macHigh);
    raw.macLow          = htonl(v.macLow);
    std::memcpy(pkt->data, &raw, sizeof(raw));
    *size = sizeof(raw);
    return true;
}


