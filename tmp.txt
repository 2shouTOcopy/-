static void *gvcp_heart_thread(void *arg)
{
	struct gvcp *gvcp = NULL; 
	int rx_len;
	socklen_t len = sizeof(struct sockaddr_in);
	thread_set_name("sc_gvcp_heart_thread");
#ifndef ASAN_SUPPORT
	thread_bind_cpu(1);
#endif
	gvcp = (struct gvcp *)arg;
	int result;
	struct gvcp_packet *aaaa;

	fd_set rset;
	if (NULL == gvcp) 
	{
		LOGE("gvcp is NULL\r\n");
		return NULL;
	}
    
    // 修改点：调用新的函数接口
    // 第一次创建时，传入 0 表示使用随机端口，传入 1 表示强制创建
	if (prepare_gvcp_heart_socket(0, 1) != 0) 
	{
		LOGE("Fail to prepare gevcp socket\r\n");
		return NULL;
	}
	
	LOGD("GVCP enter heart thread loop\r\n");
	while (1) 
	{
        // ... (循环体内部代码保持不变) ...
		if(heart_gvcp.sock_fd < 0)
		{
			usleep(100000);
			// 可以在这里增加重试逻辑，比如重新调用 prepare_gvcp_heart_socket
			continue;		
		}

		FD_ZERO(&rset);
		FD_SET(heart_gvcp.sock_fd, &rset);
		result = select(heart_gvcp.sock_fd + 1, &rset, NULL, NULL, NULL);
		if (result > 0)
		{
			if (FD_ISSET(heart_gvcp.sock_fd, &rset))
			{	
				rx_len = recvfrom(heart_gvcp.sock_fd, (void *)gvcp_heart_net.recv_buf, sizeof(gvcp_heart_net.recv_buf), 0, (struct sockaddr *)&heart_gvcp.host_addr, &len);
				if (rx_len > 0)
				{
					if (GVCP_DUMP_OPEN == gvcp_dump_type)
					{
						dump_buffer((char *)gvcp_heart_net.recv_buf, rx_len);
					}
					
					gvcp_heart_handler((struct gvcp_packet *)gvcp_heart_net.recv_buf, SC_GVCP_HEART_PORT, (ip_addr_t)heart_gvcp.host_addr.sin_addr.s_addr,
									heart_gvcp.host_addr.sin_port, rx_len);
				}
				else
				{
					LOGE("gvcp upd recvfrom ERROR\r\n");
				}
			}
		}
		else
		{
			LOGE("read socket error\n");
		}
	}
	return NULL;
}
