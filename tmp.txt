#include <iostream>
#include <string>
#include "oconfig.h" // 包含 OConfigItem 等定义，以及 parse 函数声明

// 声明与 oconfig.cpp 中的 C++14 接口函数（若 oconfig.h 已声明则可省略）
extern int oconfig_parse_string_cxx14(const char *buffer, OConfigItem *root);

// 递归打印配置树的工具函数
void printConfigItem(const OConfigItem &item, int indent = 0)
{
    // 缩进
    std::string prefix(indent, ' ');

    // 打印本节点
    std::cout << prefix << "Key: " << item.key << std::endl;
    // 如果有 values
    if (!item.values.empty()) {
        std::cout << prefix << "  Values:" << std::endl;
        for (size_t i = 0; i < item.values.size(); ++i) {
            const OConfigValue &val = item.values[i];
            switch (val.type) {
                case OConfigType::STRING:
                    std::cout << prefix << "    [STRING] " << val.getString() << std::endl;
                    break;
                case OConfigType::NUMBER:
                    std::cout << prefix << "    [NUMBER] " << val.getNumber() << std::endl;
                    break;
                case OConfigType::BOOLEAN:
                    std::cout << prefix << "    [BOOLEAN] " << (val.getBoolean() ? "true" : "false") << std::endl;
                    break;
            }
        }
    }

    // 递归打印所有子节点
    if (!item.children.empty()) {
        std::cout << prefix << "  Children:" << std::endl;
        for (size_t i = 0; i < item.children.size(); ++i) {
            printConfigItem(*item.children[i], indent + 4);
        }
    }
}

// 在此写上示例配置内容：与 “上面是配置文件的实例” 中相同
static const char *demo_config = R"CONF(
##############################################################################
# Global                                                                     #
#----------------------------------------------------------------------------#
# Global settings for the daemon.                                            #
##############################################################################

#Hostname    "localhost"
FQDNLookup   false
#BaseDir     "${prefix}/var/lib/collectd"
#PIDFile     "${prefix}/var/run/collectd.pid"
#PluginDir   "${exec_prefix}/lib/collectd"
#TypesDB     "/opt/collectd/share/collectd/types.db"

#----------------------------------------------------------------------------#
# When enabled, plugins are loaded automatically with the default options    #
# when an appropriate <Plugin ...> block is encountered.                     #
# Disabled by default.                                                       #
#----------------------------------------------------------------------------#
#AutoLoadPlugin false

#MaxReadInterval 86400
#Timeout         2
#ReadThreads     5
#WriteThreads    5


# Limit the size of the write queue. Default is no limit. Setting up a limit is
# recommended for servers handling a high volume of traffic.
#WriteQueueLimitHigh 1000000
#WriteQueueLimitLow   800000

##############################################################################
# Logging                                                                    #
#----------------------------------------------------------------------------#
# Plugins which provide logging functions should be loaded first, so log     #
# messages generated when loading or configuring other plugins can be        #
# accessed.                                                                  #
##############################################################################

#LoadPlugin syslog
LoadPlugin logfile
LoadPlugin log_logstash

<Plugin logfile>
	LogLevel debug
	File "/mnt/data/collect/log"
	Timestamp true
	PrintSeverity false
</Plugin>

<Plugin log_logstash>
	LogLevel debug
	File "${prefix}/var/log/collectd.json.log"
</Plugin>

#<Plugin syslog>
#	LogLevel debug
#</Plugin>
)CONF";


int main()
{
    // 准备一个顶层的 OConfigItem（相当于根节点）
    OConfigItem root("root");

    // 调用我们改写的解析函数（从字符串解析）
    int status = oconfig_parse_string_cxx14(demo_config, &root);
    if (status != 0) {
        std::cerr << "[ERROR] Failed to parse config from string." << std::endl;
        return 1;
    }

    // 解析成功后，打印结果
    std::cout << "===== Parsed Config Tree =====" << std::endl;
    printConfigItem(root, 0);

    // root 在栈上，不需要手动释放。其子节点由 unique_ptr 管理
    // 如果你是用 oconfig_new_item_cxx14() 动态分配的，则可调用 oconfig_free_cxx14(rootPtr)

    return 0;
}