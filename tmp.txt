#include <iostream>
#include <string>
#include <vector>
#include <functional>
#include <cstring> // 用于 strcmp

#include "configfile.h"
#include "types_parser.h" // 用于 TypesDbParser::parse_file

#include "../daemon/ModuleLoader.h" // 根据您的项目结构调整路径
#include "../daemon/ModuleBase.h"   // 根据您的项目结构调整路径


ConfigManager::ConfigManager()
{
    InitGlobalOptions();
    InitValueMapper();
    // 为 TypesDB 设置一个全局默认值，这个值可能会被配置文件覆盖。
    global_config_.setOption("TypesDB", "/usr/share/collectd/types.db");
}

ConfigManager::~ConfigManager()
{
    TypesDbParser::free_datasets(type_datasets_);
}


void ConfigManager::InitGlobalOptions()
{
    global_config_.setOption("BaseDir", "/var/lib/collectd");
    global_config_.setOption("PIDFile", "/var/run/collectd.pid");
    global_config_.setOption("FQDNLookup", "true");
    global_config_.setOption("Interval", "10");
    // ... 其他全局选项 ...
    global_config_.setOption("TypesDB", "/opt/collectd/share/collectd/types.db"); // 默认路径
}

// ... (ConfigManager 的其他方法：InitValueMapper, Dispatch*, Read 等在此请求中保持不变) ...
// ... (确保 Read 方法正确填充了 type_datasets_)

const std::vector<data_set_t>& ConfigManager::GetTypeDataSets() const {
    // 如果 type_datasets_ 在初始化后可能被并发修改，
    // 你需要在这里加锁。
    // std::lock_guard<std::mutex> lock(type_datasets_mutex_);
    return type_datasets_;
}

const data_set_t* ConfigManager::GetDataSetByName(const std::string& type_name) const {
    // 如果 type_datasets_ 在初始化后可能被并发修改，
    // 你需要在这里加锁。
    // std::lock_guard<std::mutex> lock(type_datasets_mutex_);
    for (const auto& ds : type_datasets_) {
        // data_set_t::type 是 char 数组，使用 strcmp 进行比较
        if (strcmp(ds.type, type_name.c_str()) == 0) {
            return &ds; // 返回指向向量中元素的指针
        }
    }
    return nullptr; // 未找到
}

int ConfigManager::GetDataSetByName(const char* type_name, const data_set_t** out_ds) const {
    if (out_ds == nullptr) {
        std::cerr << "ConfigManager::GetDataSetByName: out_ds parameter cannot be null." << std::endl;
        return -1; // 无效参数
    }
    // 如果 type_datasets_ 在初始化后可能被并发修改，
    // 你需要在这里加锁。
    // std::lock_guard<std::mutex> lock(type_datasets_mutex_);

    *out_ds = nullptr; // 初始化输出参数
    if (type_name == nullptr) {
        std::cerr << "ConfigManager::GetDataSetByName: type_name parameter cannot be null." << std::endl;
        return -1; // 无效参数
    }

    for (const auto& ds : type_datasets_) {
        if (strcmp(ds.type, type_name) == 0) {
            *out_ds = &ds; // 设置 out_ds 指向找到的元素
            return 0;      // 成功
        }
    }
    return -1; // 未找到 (或者可以使用如 common.h 中定义的 ENOENT 等错误码)
}


// ... (ConfigManager 的其他方法：DispatchOption, Search, Register 等)
