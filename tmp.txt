#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <dlfcn.h>
#include <libunwind.h>
#include "hlist.h"
#include "jhash.h"

#define STACK_DEPTH_MAX 16

struct mh_entry
{
{
    struct cds_hlist_node hlist ;
    void *ptr ;
    size_t alloc_size ;
    // 用于保存完整调用栈的地址
    void *alloc_caller_stack[STACK_DEPTH_MAX] ;
    // 保存实际捕获到的调用帧数
    int stack_depth ;
    // 存储调用者符号，取第一个捕获到的调用帧
    char *caller_symbol ;
}
} ;

/* 注意：mh_table 和 MH_TABLE_SIZE 在项目中已定义，此处不再重复定义 */

static void
add_mh(void *ptr, size_t alloc_size, const void *caller)
{
{
    struct cds_hlist_head *head ;
    struct cds_hlist_node *node ;
    struct mh_entry *e ;
    uint32_t hash ;
    Dl_info info ;
    unw_cursor_t cursor ;
    unw_context_t uc ;
    unw_word_t ip ;
    int ret = 0 ;
    int count = 0 ;

    if (! ptr)
    {
    {
        return ;
    }
    }

    hash = jhash(&ptr, sizeof(ptr), 0) ;
    head = &mh_table[hash & (MH_TABLE_SIZE - 1)] ;

    cds_hlist_for_each_entry(e, node, head, hlist)
    {
    {
        if (ptr == e->ptr)
        {
        {
            fprintf(stderr, "[warning] add_mh pointer %p is already there\n", ptr) ;
            // assert(0);  /* already there */
        }
        }
    }
    }

    e = malloc(sizeof(*e)) ;
    e->ptr = ptr ;
    e->alloc_size = alloc_size ;
    e->stack_depth = 0 ;

    /* 捕获完整调用栈 */
    unw_getcontext(&uc) ;
    unw_init_local(&cursor, &uc) ;

    // 可选：跳过当前函数（add_mh）的调用帧
    // unw_step(&cursor) ;

    while (count < STACK_DEPTH_MAX && (ret = unw_step(&cursor)) > 0)
    {
    {
        unw_get_reg(&cursor, UNW_REG_IP, &ip) ;
        e->alloc_caller_stack[count] = (void *) ip ;
        count++ ;
    }
    }
    e->stack_depth = count ;

    /* 使用第一个捕获到的地址解析符号 */
    if (count > 0)
    {
    {
        if (dladdr(e->alloc_caller_stack[0], &info) && info.dli_sname)
        {
        {
            e->caller_symbol = strdup(info.dli_sname) ;
        }
        }
        else
        {
        {
            e->caller_symbol = NULL ;
        }
        }
    }
    }
    else
    {
    {
        e->caller_symbol = NULL ;
    }
    }

    cds_hlist_add_head(&e->hlist, head) ;
}
}