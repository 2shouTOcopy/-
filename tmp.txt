#include "memory.h"
#include "../daemon/PluginService.h" // For PluginService, value_list_t, value_t, VALUE_LIST_INIT, INFO, ERROR macros
                                     // Also assuming gauge_t is effectively defined/usable through includes here or ModuleBase.h

#include <sys/sysinfo.h> // For struct sysinfo and sysinfo()
#include <cstring>       // For snprintf, strerror
#include <cerrno>        // For errno
#include <cassert>       // For assert

// Placeholder definitions for logging macros and types if not provided by included headers.
// These should ideally come from your project's common headers (e.g., PluginService.h or similar).
/*
#ifndef INFO
#include <cstdio> // Required for fprintf, stdout
#define INFO(format, ...) do { fprintf(stdout, "[INFO] "); fprintf(stdout, format, ##__VA_ARGS__); fprintf(stdout, "\n"); } while(0)
#endif

#ifndef ERROR
#include <cstdio> // Required for fprintf, stderr
#define ERROR(format, ...) do { fprintf(stderr, "[ERROR] "); fprintf(stderr, format, ##__VA_ARGS__); fprintf(stderr, "\n"); } while(0)
#endif

// Assuming value_t, value_list_t, and VALUE_LIST_INIT are defined elsewhere.
// Example:
// typedef double gauge_t;
// typedef struct { gauge_t gauge; /* other types */ } value_t;
// typedef struct value_list_s {
//     value_t *values;
//     size_t values_len;
//     char plugin[64];
//     char type[64];
//     // Other fields like plugin_instance, type_instance, host, time, interval if used by PluginService
// } value_list_t;
// #define VALUE_LIST_INIT {nullptr, 0, {0}, {0}} // Example initialization
*/


/**
 * @brief Submits a gauge metric to the PluginService.
 *
 * @param metric_name The specific name of the metric (e.g., "memory_total_bytes"). This will be used as the 'type'.
 * @param value The value of the metric.
 */
void CMemoryModule::submitMetric(const char* metric_name, gauge_t value)
{
    value_list_t vl = VALUE_LIST_INIT; // Initialize using the provided macro or C++11 zero-initialization if appropriate
    value_t temp_val;                  // Structure to hold the actual metric value

    // In C++11, ensure temp_val is properly initialized before assigning to a union member.
    // If value_t is a union, this assignment is specific to the 'gauge' member.
    temp_val.gauge = value;

    vl.values = &temp_val;
    vl.values_len = 1;

    // Set the plugin name to "memory"
    // Using snprintf for safe string copying into fixed-size buffers.
    snprintf(vl.plugin, sizeof(vl.plugin), "memory");
    // Ensure null-termination, though snprintf should do this if there's space.
    vl.plugin[sizeof(vl.plugin) - 1] = '\0';

    // Set the type to the specific metric being reported (e.g., "memory_free_bytes")
    snprintf(vl.type, sizeof(vl.type), "%s", metric_name);
    vl.type[sizeof(vl.type) - 1] = '\0'; // Ensure null-termination

    // Log the submission, similar to the uptime plugin's logging format
    // Assuming gauge_t might be float or double, use %lf for logging.
    // The INFO macro should handle printf-style arguments.
    INFO("[memory] %s Submit :%lf", metric_name, static_cast<double>(value));
    
    PluginService::Instance().dispatchValues(&vl);
}

/**
 * @brief Retrieves system memory information using the sysinfo system call.
 *
 * @param info Reference to a sysinfo struct to be filled.
 * @return true if sysinfo call was successful, false otherwise.
 */
bool CMemoryModule::getSysMemoryInfo(struct sysinfo &info_ref)
{
    if (sysinfo(&info_ref) != 0)
    {
        // Log error, consistent with uptime plugin's error logging
        ERROR("memory plugin: Error calling sysinfo: %s", strerror(errno));
        return false;
    }
    return true;
}

/**
 * @brief Reads memory and swap statistics and submits them.
 *
 * This method is called by the plugin framework to collect and report data.
 * @return 0 on success, -1 on failure.
 */
int CMemoryModule::read()
{
    INFO("[memory] read"); // Log entry into the read method

    struct sysinfo s_info {}; // C++11 uniform initialization
    if (!getSysMemoryInfo(s_info))
    {
        return -1; // Error already logged by getSysMemoryInfo
    }

    // sysinfo.mem_unit is the size of memory units in bytes.
    // All RAM and swap values from sysinfo are in these units.
    unsigned long long mem_unit = s_info.mem_unit;
    if (mem_unit == 0) { // Should not happen with a valid sysinfo call, but defensive check
        ERROR("memory plugin: sysinfo.mem_unit is 0, cannot calculate memory values.");
        return -1;
    }

    // --- Physical Memory Metrics ---
    unsigned long long total_ram_bytes = static_cast<unsigned long long>(s_info.totalram) * mem_unit;
    unsigned long long free_ram_bytes = static_cast<unsigned long long>(s_info.freeram) * mem_unit;
    unsigned long long shared_ram_bytes = static_cast<unsigned long long>(s_info.sharedram) * mem_unit;
    unsigned long long buffer_ram_bytes = static_cast<unsigned long long>(s_info.bufferram) * mem_unit;
    
    // Calculate used RAM. A common definition is Total - Free.
    // For more advanced "used" (e.g., Total - Free - Buffers - Cache), /proc/meminfo parsing would be needed.
    // Sticking to sysinfo, Total - Free is a straightforward interpretation.
    unsigned long long used_ram_bytes = total_ram_bytes - free_ram_bytes;

    submitMetric("memory_total_bytes", static_cast<gauge_t>(total_ram_bytes));
    submitMetric("memory_free_bytes", static_cast<gauge_t>(free_ram_bytes));
    submitMetric("memory_shared_bytes", static_cast<gauge_t>(shared_ram_bytes));
    submitMetric("memory_buffer_bytes", static_cast<gauge_t>(buffer_ram_bytes));
    submitMetric("memory_used_bytes", static_cast<gauge_t>(used_ram_bytes));

    if (total_ram_bytes > 0)
    {
        gauge_t percent_used = (static_cast<gauge_t>(used_ram_bytes) / static_cast<gauge_t>(total_ram_bytes)) * 100.0;
        submitMetric("memory_percent_used", percent_used);
    }
    else
    {
        submitMetric("memory_percent_used", 0.0); // Avoid division by zero; report 0% if total RAM is zero
    }

    // --- Swap Space Metrics ---
    unsigned long long total_swap_bytes = static_cast<unsigned long long>(s_info.totalswap) * mem_unit;
    unsigned long long free_swap_bytes = static_cast<unsigned long long>(s_info.freeswap) * mem_unit;
    unsigned long long used_swap_bytes = total_swap_bytes - free_swap_bytes;

    submitMetric("swap_total_bytes", static_cast<gauge_t>(total_swap_bytes));
    submitMetric("swap_free_bytes", static_cast<gauge_t>(free_swap_bytes));
    submitMetric("swap_used_bytes", static_cast<gauge_t>(used_swap_bytes));

    if (total_swap_bytes > 0)
    {
        gauge_t swap_percent_used = (static_cast<gauge_t>(used_swap_bytes) / static_cast<gauge_t>(total_swap_bytes)) * 100.0;
        submitMetric("swap_percent_used", swap_percent_used);
    }
    else
    {
        submitMetric("swap_percent_used", 0.0); // Avoid division by zero; report 0% if total swap is zero
    }
    
    return 0; // Success
}

/**
 * @brief Factory function to create an instance of CMemoryModule.
 *
 * @return CAbstractUserModule* Pointer to the newly created CMemoryModule instance.
 */
CAbstractUserModule* CreateModule()
{
    return new (std::nothrow) CMemoryModule(); // Using std::nothrow to align with typical embedded/plugin practices
                                              // where exceptions might be disabled or undesirable.
                                              // Caller should check for nullptr.
}

/**
 * @brief Factory function to destroy an instance of CMemoryModule.
 *
 * @param pUserModule Pointer to the CMemoryModule instance to be destroyed.
 */
void DestroyModule(CAbstractUserModule* pUserModule)
{
    assert(pUserModule != nullptr); // Use C++11 nullptr for assertions
    delete pUserModule;
    // Setting the local pUserModule pointer to nullptr here has no effect on the caller's pointer.
    // pUserModule = nullptr; // Kept if matching an existing style, but functionally limited for local param.
}

