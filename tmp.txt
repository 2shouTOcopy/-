#include "thread_plugin.h"
#include <iostream>
#include <iomanip> // For std::fixed and std::setprecision

void print_thread_info(const ThreadInfo& info) {
    std::cout << "----------------------------------------\n";
    std::cout << "线程ID (TID): " << info.id << "\n";
    std::cout << "线程名称: " << info.name << "\n";
    std::cout << "线程状态: " << info.state_to_string() << "\n";
    std::cout << "优先级: " << info.priority << " (Nice: " << info.nice_value << ")\n";
    std::cout << "调度策略: " << info.policy_to_string() << "\n";
    
    std::cout << std::fixed << std::setprecision(2);
    std::cout << "平均CPU使用率 (用户态): " << info.cpu_usage_user_avg_percent << "%\n";
    std::cout << "平均CPU使用率 (内核态): " << info.cpu_usage_system_avg_percent << "%\n";
    std::cout << "CPU耗时 (用户态 ms): " << info.runtime_user_ms << "\n";
    std::cout << "CPU耗时 (系统态 ms): " << info.runtime_system_ms << "\n";
    std::cout << "内存占用 (栈 KB): " << info.memory_stack_kb << "\n";
    std::cout << "打开文件描述符数: " << info.open_files_count << "\n";

    std::cout << "内核等待函数 (WCHAN): " << info.wchan << "\n";

    if (!info.call_stack.empty()) {
        std::cout << "调用栈:\n";
        for (const auto& frame : info.call_stack) {
            std::cout << "  " << frame << "\n";
        }
    }
    // std::cout << "调度延迟 (ns): N/A via /proc\n"; // Placeholder
    std::cout << "自愿上下文切换: " << info.voluntary_context_switches << "\n";
    std::cout << "非自愿上下文切换: " << info.nonvoluntary_context_switches << "\n";
}

void print_aggregate_stats(const AggregateStats& stats) {
    std::cout << "========================================\n";
    std::cout << "聚合分析:\n";
    std::cout << "总线程数: " << stats.total_threads << "\n";
    std::cout << "线程状态统计:\n";
    for(const auto& pair : stats.threads_by_state) {
        ThreadInfo temp_info; // Just to use state_to_string
        temp_info.state = pair.first;
        std::cout << "  - " << temp_info.state_to_string() << ": " << pair.second << "\n";
    }

    if (!stats.cpu_hot_thread_ids.empty()) {
        std::cout << "CPU 热点线程 ID (按总CPU时间排序, 最多5个): ";
        for (size_t i = 0; i < stats.cpu_hot_thread_ids.size(); ++i) {
            std::cout << stats.cpu_hot_thread_ids[i] << (i == stats.cpu_hot_thread_ids.size() - 1 ? "" : ", ");
        }
        std::cout << "\n";
    }
    std::cout << "========================================\n";
}

int main() {
    ThreadPlugin plugin;
    
    std::cout << "调用 plugin.flush() 获取当前进程的线程信息...\n";
    auto result = plugin.flush();
    
    const auto& all_threads = result.first;
    const auto& aggregate_data = result.second;

    std::cout << "\n--- 单个线程信息 ---\n";
    if (all_threads.empty()) {
        std::cout << "未能获取到线程信息 (可能是权限问题或 /proc 解析问题).\n";
    } else {
        for (const auto& t_info : all_threads) {
            print_thread_info(t_info);
        }
    }
    

    std::cout << "\n--- 聚合统计信息 ---\n";
    print_aggregate_stats(aggregate_data);
    
    // 让主线程做点事，产生一些CPU消耗，方便观察
    std::cout << "\n主线程将进行一些计算...\n";
    volatile unsigned long long counter = 0;
    for (unsigned long long i = 0; i < 2000000000ULL; ++i) { // Adjust loop for desired CPU time
        counter++;
    }
    std::cout << "计算完成. Counter: " << counter << "\n";
    std::cout << "再次调用 plugin.flush()...\n";

    result = plugin.flush();
    const auto& all_threads_after = result.first;
    const auto& aggregate_data_after = result.second;

    std::cout << "\n--- 单个线程信息 (第二次) ---\n";
     if (all_threads_after.empty()) {
        std::cout << "未能获取到线程信息 (可能是权限问题或 /proc 解析问题).\n";
    } else {
        for (const auto& t_info : all_threads_after) {
            print_thread_info(t_info);
        }
    }
    std::cout << "\n--- 聚合统计信息 (第二次) ---\n";
    print_aggregate_stats(aggregate_data_after);


    return 0;
}
