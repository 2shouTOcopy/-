#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <sstream>
#include <dirent.h>
#include <unistd.h>
#include <sys/types.h>
#include <algorithm> // For std::remove
#include <iomanip>   // For std::setw, std::left

// 假设的 os_get_pid_by_name 函数声明 (C风格)
// 实际项目中，你需要链接包含此函数实现的库或源文件
extern "C" int os_get_pid_by_name(const char *process_name, pid_t *pids, int *count);

struct ThreadInfo {
    pid_t tid;
    std::string name;
    std::string state_str;
    char state_char;
    long nice_val;
    long policy_val;
    std::string policy_str;
};

// --- 辅助函数 ---

// 根据状态字符获取可读的状态字符串
std::string get_thread_state_str_cpp(char state_char) {
    switch (state_char) {
        case 'R': return "RUNNING";
        case 'S': return "SLEEPING (Interruptible)";
        case 'D': return "SLEEPING (Uninterruptible)";
        case 'Z': return "ZOMBIE";
        case 'T': return "STOPPED";
        case 't': return "TRACING_STOP";
        case 'X': return "DEAD";
        case 'I': return "IDLE"; // Kernel 5.14+
        case 'P': return "PARKED"; // Kernel 5.10+
        default:  return "UNKNOWN";
    }
}

// 根据调度策略数字获取可读的策略字符串
std::string get_scheduler_policy_str_cpp(long policy_num) {
    switch (policy_num) {
        case 0:  return "SCHED_OTHER";
        case 1:  return "SCHED_FIFO";
        case 2:  return "SCHED_RR";
        case 3:  return "SCHED_BATCH";
        case 4:  return "SCHED_ISO"; // (通常已弃用)
        case 5:  return "SCHED_IDLE";
        case 6:  return "SCHED_DEADLINE";
        default: return "UNKNOWN_POLICY";
    }
}

// --- 插件核心函数 ---

/**
 * @brief 刷新并打印指定进程的线程信息 (C++ 版本)
 *
 * @param target_process_name 要查询的目标进程名称
 * @return 0 成功, -1 失败
 */
int thread_plugin_flush_cpp(const char *target_process_name) {
    pid_t pids[10]; // 假设最多返回10个同名进程的PID
    int pid_count = 10;
    int ret;

    std::cout << "--- Thread Plugin (C++): Flushing info for process \"" << target_process_name << "\" ---" << std::endl;

    ret = os_get_pid_by_name(target_process_name, pids, &pid_count);
    if (ret != 0 || pid_count == 0) {
        std::cerr << "Error: Could not get PID for process \"" << target_process_name
                  << "\". os_get_pid_by_name returned " << ret << ", pid_count " << pid_count << "." << std::endl;
        if (pid_count == 0 && ret == 0) {
            std::cerr << "Process \"" << target_process_name << "\" not found." << std::endl;
        }
        return -1;
    }

    pid_t target_pid = pids[0]; // 只处理找到的第一个PID
    std::cout << "Target Process: " << target_process_name << " (PID: " << target_pid << ")" << std::endl;
    std::cout << "---------------------------------------------------------------------------------------------------" << std::endl;
    std::cout << "| " << std::left << std::setw(8) << "TID"
              << "| " << std::left << std::setw(20) << "Name"
              << "| " << std::left << std::setw(28) << "State"
              << "| " << std::left << std::setw(8) << "Nice"
              << "| " << std::left << std::setw(15) << "Policy"
              << "| " << std::left << std::setw(10) << "RawPolicy" << "|" << std::endl;
    std::cout << "---------------------------------------------------------------------------------------------------" << std::endl;

    std::string task_path_str = "/proc/" + std::to_string(target_pid) + "/task";
    DIR *dir = opendir(task_path_str.c_str());
    if (!dir) {
        perror("Error opening task directory");
        std::cerr << "Failed to open: " << task_path_str << " (PID: " << target_pid
                  << "). Do you have permissions? Is the process running?" << std::endl;
        return -1;
    }

    struct dirent *entry;
    while ((entry = readdir(dir)) != NULL) {
        if (entry->d_type == DT_DIR) {
            char *endptr;
            long tid_long = strtol(entry->d_name, &endptr, 10);
            if (*endptr == '\0') { // 是纯数字目录名
                pid_t tid = static_cast<pid_t>(tid_long);
                ThreadInfo info;
                info.tid = tid;
                info.nice_val = 0; // Default
                info.policy_val = -1; // Default to indicate error or not found
                info.state_char = '?';

                // 1. 获取线程名称 from /comm
                std::string comm_path_str = task_path_str + "/" + entry->d_name + "/comm";
                std::ifstream comm_file(comm_path_str);
                if (comm_file.is_open()) {
                    std::getline(comm_file, info.name);
                    comm_file.close();
                } else {
                    info.name = "N/A";
                }

                // 2. 获取线程状态、优先级、调度策略 from /stat
                std::string stat_path_str = task_path_str + "/" + entry->d_name + "/stat";
                std::ifstream stat_file(stat_path_str);
                if (stat_file.is_open()) {
                    std::string line;
                    std::getline(stat_file, line);
                    stat_file.close();

                    std::stringstream ss(line);
                    std::vector<std::string> fields;
                    std::string field_val;
                    while (ss >> field_val) {
                        fields.push_back(field_val);
                    }
                    
                    // /proc/[pid]/stat fields (1-indexed from man page, 0-indexed for vector)
                    // Field 1 (index 0): TID (already have)
                    // Field 2 (index 1): (comm) (name in parens, already read from /comm, more reliable)
                    // Field 3 (index 2): state
                    // ...
                    // Field 19 (index 18): nice value
                    // ...
                    // Field 40 (index 39): policy

                    if (fields.size() > 2) { // Need at least TID, (comm), state
                        info.state_char = fields[2][0]; // State is the 3rd field
                    }

                    if (fields.size() > 18) { // Check if nice field exists
                        try {
                            info.nice_val = std::stol(fields[18]); // Nice value is the 19th field
                        } catch (const std::exception& e) {
                            // std::cerr << "Warning: Could not parse nice value for TID " << tid << ": " << fields[18] << std::endl;
                            info.nice_val = -999; // Indicate parsing error
                        }
                    }

                    if (fields.size() > 39) { // Check if policy field exists
                         try {
                            info.policy_val = std::stol(fields[39]); // Policy is the 40th field
                        } catch (const std::exception& e) {
                            // std::cerr << "Warning: Could not parse policy value for TID " << tid << ": " << fields[39] << std::endl;
                            // info.policy_val remains -1 (or some other error indicator)
                        }
                    }
                } else {
                     // std::cerr << "Warning: Could not open " << stat_path_str << " for TID " << tid << std::endl;
                }
                
                info.state_str = get_thread_state_str_cpp(info.state_char);
                info.policy_str = get_scheduler_policy_str_cpp(info.policy_val);

                std::cout << "| " << std::left << std::setw(8) << info.tid
                          << "| " << std::left << std::setw(20) << info.name
                          << "| " << std::left << std::setw(28) << (info.state_str + " ('" + info.state_char + "')")
                          << "| " << std::left << std::setw(8) << info.nice_val
                          << "| " << std::left << std::setw(15) << info.policy_str
                          << "| " << std::left << std::setw(10) << info.policy_val << "|" << std::endl;
            }
        }
    }
    closedir(dir);
    std::cout << "---------------------------------------------------------------------------------------------------" << std::endl;
    std::cout << "--- Thread Plugin (C++): Flush complete ---" << std::endl << std::endl;
    return 0;
}

// --- main 函数用于测试插件 ---
#ifdef THREAD_PLUGIN_TEST_MAIN_CPP
// 模拟的 os_get_pid_by_name (与C版本相同)
#include <cstdio>  // For popen, pclose, fscanf in C-style mock
#include <cstring> // For strcmp in C-style mock
#include <libgen.h> // For basename in C-style mock (might need to link -lgen or ensure POSIX)

extern "C" int os_get_pid_by_name(const char *process_name, pid_t *pids, int *count) {
    char cmd[256];
    snprintf(cmd, sizeof(cmd), "pidof %s", process_name);
    FILE *fp = popen(cmd, "r");
    
    if (fp == NULL) {
        perror("Failed to run pidof");
        *count = 0;
        return -1;
    }

    int found_pids = 0;
    while (found_pids < *count && fscanf(fp, "%d", &pids[found_pids]) == 1) {
        found_pids++;
    }
    
    int status = pclose(fp);
    if (status == -1) {
        perror("pclose failed");
    }

    if (found_pids > 0) {
        *count = found_pids;
        return 0; // Success
    }

    // Fallback: pidof failed or found nothing, try to search /proc (less efficient)
    // std::cout << "pidof failed for " << process_name << " or found no PIDs, trying /proc scan." << std::endl;
    DIR *proc_dir = opendir("/proc");
    if (!proc_dir) {
        *count = 0;
        return -2;
    }
    struct dirent *entry;
    found_pids = 0; // Reset for /proc scan
    char target_exe_name[256];
    strncpy(target_exe_name, process_name, sizeof(target_exe_name) -1);
    target_exe_name[sizeof(target_exe_name)-1] = '\0';


    while ((entry = readdir(proc_dir)) != NULL && found_pids < *count) {
        char *endptr;
        long pid_long = strtol(entry->d_name, &endptr, 10);
        if (*endptr == '\0') { // Is a process directory
            char exe_path[512];
            char exe_link[512];
            snprintf(exe_path, sizeof(exe_path), "/proc/%ld/exe", pid_long);
            ssize_t len = readlink(exe_path, exe_link, sizeof(exe_link) - 1);
            if (len != -1) {
                exe_link[len] = '\0';
                char *bname = basename(exe_link); // basename might modify its argument if not POSIX standard.
                                                  // It's safer to pass a copy if exe_link is needed later.
                if (bname && strcmp(bname, target_exe_name) == 0) {
                    pids[found_pids++] = static_cast<pid_t>(pid_long);
                }
            }
        }
    }
    closedir(proc_dir);
    
    if(found_pids > 0){
        *count = found_pids;
        return 0;
    }

    *count = 0;
    return -3; // Not found
}

int main() {
    std::cout << "Attempting to get thread info for 'systemd' (usually PID 1)..." << std::endl;
    thread_plugin_flush_cpp("systemd");

    // 替换 "your_test_app_name"
    std::cout << "\nAttempting to get thread info for 'm320_app' (replace with a running app name if needed)..." << std::endl;
    std::cout << "Please ensure 'm320_app' or another test app is running." << std::endl;
    thread_plugin_flush_cpp("m320_app");
    
    // Example: try to find info for a common desktop process if you have one
    // thread_plugin_flush_cpp("gnome-shell"); // or "kwin_x11", "Xorg", etc.

    return 0;
}
#endif // THREAD_PLUGIN_TEST_MAIN_CPP
