好的，针对 ARM Cortex-A9 + uClibc 环境，我们编写一个最小化的 Demo 来验证 _Unwind_Backtrace。
这个 Demo 会模拟几层函数调用，并在最内层触发堆栈回溯，打印出程序计数器（PC）地址。
1. 代码实现 (unwind_test.c)
#include <stdio.h>
#include <stdlib.h>
#include <unwind.h> // GCC 内建头文件
#include <stdint.h>

#define MAX_DEPTH 20

// 传递给回调的上下文结构
struct trace_arg {
    void **buffer;
    int current_idx;
    int max_depth;
};

// Unwind 回调函数
// 每一层堆栈帧都会进入此函数
static _Unwind_Reason_Code unwind_callback(struct _Unwind_Context *context, void *arg) {
    struct trace_arg *tracing = (struct trace_arg *)arg;

    // 获取当前帧的 IP (Instruction Pointer / PC)
    // 注意：这里的 IP 通常是函数的返回地址
    uintptr_t ip = _Unwind_GetIP(context);

    if (ip != 0) {
        if (tracing->current_idx < tracing->max_depth) {
            tracing->buffer[tracing->current_idx++] = (void *)ip;
            return _URC_NO_REASON; // 继续回溯上一层
        } else {
            return _URC_END_OF_STACK; // 数组满了，停止
        }
    }
    return _URC_NO_REASON;
}

// 封装后的获取堆栈函数
int capture_backtrace(void **buffer, int max_depth) {
    struct trace_arg arg;
    arg.buffer = buffer;
    arg.current_idx = 0;
    arg.max_depth = max_depth;

    _Unwind_Backtrace(unwind_callback, &arg);

    return arg.current_idx;
}

// --- 测试用的嵌套函数 ---

void print_stack_trace() {
    void *buffer[MAX_DEPTH];
    int depth = capture_backtrace(buffer, MAX_DEPTH);

    printf("Stack trace (depth %d):\n", depth);
    printf("------------------------\n");
    for (int i = 0; i < depth; i++) {
        // 打印原始地址
        printf("[%02d] Address: %p\n", i, buffer[i]);
    }
    printf("------------------------\n");
    printf("Use addr2line to verify: addr2line -e unwind_test -f <Address>\n");
}

void func_c() {
    printf("Inside func_c, capturing backtrace...\n");
    print_stack_trace();
}

void func_b() {
    func_c();
}

void func_a() {
    func_b();
}

int main() {
    printf("Starting unwind test on ARM uClibc...\n");
    func_a();
    return 0;
}

2. 编译指令
请务必加上 -funwind-tables 选项，这对于 ARM 平台通过 _Unwind_Backtrace 获取堆栈至关重要（它会强制生成 .ARM.extab 和 .ARM.exidx 段）。同时也建议加上 -g 用于后续验证符号。
# 你的交叉编译工具链
CC=arm-ca9-linux-uclibcgnueabihf-gcc

# 编译
$CC -g -funwind-tables -o unwind_test unwind_test.c

3. 如何在板子上验证
 * 运行程序：
   将 unwind_test 拷贝到板子上运行：
   ./unwind_test

 * 查看输出：
   你会看到类似这样的输出：
   Starting unwind test on ARM uClibc...
Inside func_c, capturing backtrace...
Stack trace (depth 5):
------------------------
[00] Address: 0x10548  <-- print_stack_trace 内的某处
[01] Address: 0x1058c  <-- func_c 的返回地址
[02] Address: 0x105a4  <-- func_b 的返回地址
[03] Address: 0x105bc  <-- func_a 的返回地址
[04] Address: 0x105e4  <-- main 的返回地址
------------------------

 * 验证准确性 (PC端操作)：
   在开发机上，使用交叉工具链的 addr2line 来反解这些地址，确认是否对应正确的函数行号。
   # 替换为你工具链里的 addr2line
arm-ca9-linux-uclibcgnueabihf-addr2line -e unwind_test -f 0x1058c 0x105a4

   如果输出显示了 func_c 调用 print_stack_trace 的位置，以及 func_b 调用 func_c 的位置，那就说明移植成功了。
4. 常见问题排查 (Troubleshooting)
 * 只能打出 1 层堆栈？
   这通常是因为编译时缺少 unwind 信息。请确认 CFLAGS 中包含了 -funwind-tables 或者是 -fasynchronous-unwind-tables。对于 ARM 架构，这比 Frame Pointer 更重要。
 * 地址偏差？
   _Unwind_GetIP 获取的是返回地址（Return Address）。在 addr2line 时，对应的代码行通常是“调用指令的下一行”。如果你想看精确的调用点，手动减去 4 字节（ARM指令集）通常能定位到 BL 指令那一行。
 * 链接错误？
   如果提示找不到符号，尝试显式链接 libgcc_s：-lgcc_s。但在 uClibc 工具链中，通常 gcc 会自动处理好。
你可以先跑一下这个 demo，如果能出结果，就可以放心地把这套逻辑集成到你的 memleak-finder.c 里替换掉原来的 glibc backtrace() 了。
