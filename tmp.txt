// src/redline_manager.cpp
#include "redline_manager.hpp"
#include "redline_store.hpp"
#include "redline_wire.h"
#include "redline_crypto.hpp"
#include "redline_tls.hpp"

#include <cstring>

RedlineManager& RedlineManager::Instance() {
    static RedlineManager inst;
    return inst;
}

RedlineManager::RedlineManager() {
    std::memset(&solid_, 0, sizeof(solid_));
    std::memset(&dev_,   0, sizeof(dev_));
    std::memset(&cookie_meta_, 0, sizeof(cookie_meta_));
}

RedlineManager::~RedlineManager() {
    cookie_thr_run_ = false;
    if (cookie_thr_.joinable()) cookie_thr_.join();
}

int RedlineManager::LoadSolidParams() {
    std::lock_guard<std::mutex> lk(mtx_);
    return RedlineStore::Load(solid_);
}

int RedlineManager::SaveSolidParams() {
    std::lock_guard<std::mutex> lk(mtx_);
    return RedlineStore::Save(solid_);
}

uint8_t RedlineManager::GetActiveSts() const {
    std::lock_guard<std::mutex> lk(mtx_);
    return solid_.bActiveSts;
}
uint8_t RedlineManager::GetLockSts() const {
    std::lock_guard<std::mutex> lk(mtx_);
    return dev_.lock_sts;
}
uint16_t RedlineManager::GetLockTime() const {
    std::lock_guard<std::mutex> lk(mtx_);
    return dev_.lock_times;
}

int RedlineManager::GetLoginSts() const {
    std::lock_guard<std::mutex> lk(mtx_);
    return dev_.login_sts1;
}
int RedlineManager::SetLoginSts(int sts) {
    std::lock_guard<std::mutex> lk(mtx_);
    dev_.login_sts1 = sts;
    return REDL_OK;
}
int RedlineManager::GetAuthSts() const {
    std::lock_guard<std::mutex> lk(mtx_);
    return dev_.auth_sts;
}
int RedlineManager::GetUpgAuthSts() const {
    std::lock_guard<std::mutex> lk(mtx_);
    return dev_.upg_auth;
}

const uint8_t* RedlineManager::GetInitDropbearCmd() const {
    static const uint8_t kStub[] = {0}; // TODO: 如有初始脚本/命令，可替换
    return kStub;
}
bool RedlineManager::IsSupRegOperation() const {
    return true; // TODO: 按产品策略返回
}

void RedlineManager::StartCookieMonitor() {
    bool expected = false;
    if (!cookie_thr_run_.compare_exchange_strong(expected, true)) return;
    cookie_thr_ = std::thread(&RedlineManager::cookieThreadLoop_, this);
}

void RedlineManager::UpdateCookie(const char* cookie) {
    std::lock_guard<std::mutex> lk(mtx_);
    std::snprintf(this->cookie_meta_.last_cookie, sizeof(cookie_meta_.last_cookie),
                  "%s", cookie ? cookie : "");
    gettimeofday(&cookie_meta_.update_time, nullptr);
    if (session_.online) {
        std::memset(session_.cookie.data(), 0, session_.cookie.size());
        std::memcpy(session_.cookie.data(), this->cookie_meta_.last_cookie,
                    std::min(sizeof(cookie_meta_.last_cookie), session_.cookie.size()));
        session_.cookie_update_tp = std::chrono::steady_clock::now();
    }
}

void RedlineManager::cookieThreadLoop_() {
    using namespace std::chrono;
    const auto kTTL = minutes(3); // 鉴权窗口3分钟
    while (cookie_thr_run_) {
        std::this_thread::sleep_for(seconds(1));
        std::lock_guard<std::mutex> lk(mtx_);
        if (!session_.online) continue;
        if (session_.cookie_update_tp.time_since_epoch().count() == 0) continue;
        if (steady_clock::now() - session_.cookie_update_tp > kTTL) {
            dev_.cookie_timeout_sts = 1;
            session_.online = false; // 超时下线
        }
    }
}

bool RedlineManager::isLocked_() const {
    // TODO: 结合 lock_start_time + lock_times 计算剩余锁定时间
    return dev_.lock_sts != 0;
}

void RedlineManager::punishOnLoginFail_() {
    // 登录失败计数/锁定
    dev_.login_times += 1;
    if (dev_.login_times >= REDLINE_LOGIN_RETRY_TIME) {
        dev_.lock_sts = 1;
        gettimeofday(&dev_.lock_start_time, nullptr);
        dev_.lock_times = 60; // 例如锁定60s（按你现有逻辑替换）
    }
}

void RedlineManager::clearLoginFail_() {
    dev_.login_times = 0;
    dev_.lock_sts = 0;
    dev_.lock_times = 0;
}

bool RedlineManager::TryAcquireSession() {
    std::lock_guard<std::mutex> lk(mtx_);
    if (session_.online) return false;
    session_.online = true;
    return true;
}

void RedlineManager::ReleaseSession() {
    std::lock_guard<std::mutex> lk(mtx_);
    session_.online = false;
}

bool RedlineManager::HasActiveSession() const {
    std::lock_guard<std::mutex> lk(mtx_);
    return session_.online;
}

// ========= 命令处理（示范实现：Login；其它保持参数校验+TODO桩） =========

int RedlineManager::HandleInterchange(const gvcp_packet* req, gvcp_packet* ack,
                                      unsigned short /*pkt_id*/, int* size, bool /*broadcast*/) {
    if (!req || !ack || !size) return REDL_EPARAM;
    // TODO: 解析 REDLINE_INTERCHANGE_CMD_T，生成 salt/enRandomString/devE1
    *size = 0;
    return REDL_OK;
}

int RedlineManager::HandleActive(const gvcp_packet* req, gvcp_packet* ack,
                                 unsigned short /*pkt_id*/, int* size) {
    if (!req || !ack || !size) return REDL_EPARAM;
    if (GetActiveSts() == DEV_ACTIVATED) return REDL_OK; // 幂等

    // TODO: 校验 enPassword/en1 计算，写 solid_.bActiveSts = DEV_ACTIVATED
    {
        std::lock_guard<std::mutex> lk(mtx_);
        solid_.bActiveSts = DEV_ACTIVATED;
    }
    *size = 0;
    return SaveSolidParams();
}

int RedlineManager::HandleRestore(const gvcp_packet* req, gvcp_packet* ack,
                                  unsigned short /*pkt_id*/, int* size) {
    if (!req || !ack || !size) return REDL_EPARAM;
    // TODO: 恢复激活（口令/签名校验通过后生效）
    *size = 0;
    return REDL_OK;
}

int RedlineManager::HandleLogin(const gvcp_packet* req, gvcp_packet* ack,
                                unsigned short /*pkt_id*/, int* size, bool /*broadcast*/) {
    if (!req || !ack || !size) return REDL_EPARAM;
    if (GetActiveSts() != DEV_ACTIVATED) return REDL_ENOTACTIVE;
    if (isLocked_()) return REDL_ESTATE;

    RL_LoginCmdView cmd{};
    if (!RL_ParseLoginCmd(req, cmd)) {
        punishOnLoginFail_();
        return REDL_EPARAM;
    }

    // A/B 互斥：仅允许唯一在线
    if (!TryAcquireSession()) {
        punishOnLoginFail_();
        return REDL_EBUSY;
    }

    // TODO: 使用 cmd.enString 结合随机串/盐进行校验，计算 devEn/cookie
    RL_LoginAckView ackv{};
    ackv.keepAlivePort  = 0;  // 由产品分配
    ackv.fileAccessPort = 0;  // 由产品分配
    ackv.loginFailedTimes = dev_.login_times;
    ackv.remainLogTimes   = (dev_.login_times < REDLINE_LOGIN_RETRY_TIME)
                          ? (REDLINE_LOGIN_RETRY_TIME - dev_.login_times) : 0;

    // 生成/更新 Cookie（示例：占位）
    {
        std::lock_guard<std::mutex> lk(mtx_);
        std::memset(session_.cookie.data(), 0, session_.cookie.size());
        std::memcpy(session_.cookie.data(), "COOKIE_PLACEHOLDER", 16);
        session_.cookie_update_tp = std::chrono::steady_clock::now();
        std::memcpy(ackv.cookie.data(), session_.cookie.data(), session_.cookie.size());
        // devEn: 使用 cookie 作为随机串计算摘要后取后8字节（此处占位）
        std::memset(ackv.devEn.data(), 0xCD, ackv.devEn.size());
    }

    if (!RL_WriteLoginAck(ack, ackv, size)) {
        ReleaseSession();
        punishOnLoginFail_();
        return REDL_EPARAM;
    }

    clearLoginFail_();
    SetLoginSts(LOGGED_IN);
    return REDL_OK;
}

int RedlineManager::HandleChangePwd(const gvcp_packet* req, gvcp_packet* ack,
                                    unsigned short /*pkt_id*/, int* size) {
    if (!req || !ack || !size) return REDL_EPARAM;
    if (GetLoginSts() != LOGGED_IN) return REDL_EPERM;
    // TODO: 校验 en1String；解密 newPassword；更新固化
    *size = 0;
    return SaveSolidParams();
}

int RedlineManager::HandleChangeIP(const gvcp_packet* req, gvcp_packet* ack,
                                   unsigned short /*pkt_id*/, int* size) {
    if (!req || !ack || !size) return REDL_EPARAM;
    // TODO: 仅允许在鉴权窗口（auth_sts==1 && 未超3min）操作
    *size = 0;
    return REDL_OK;
}

int RedlineManager::HandleResetPwd(const gvcp_packet* req, gvcp_packet* ack,
                                   unsigned short /*pkt_id*/, int* size, ip_addr_t /*peer_ip*/) {
    if (!req || !ack || !size) return REDL_EPARAM;
    // TODO: 校验 encryptString + ivString；重置后 Save
    *size = 0;
    return SaveSolidParams();
}

int RedlineManager::HandleUpgrade(const gvcp_packet* req, gvcp_packet* ack,
                                  unsigned short /*pkt_id*/, int* size) {
    if (!req || !ack || !size) return REDL_EPARAM;
    // TODO: upg_auth 检查、分配upgPort，填充 REDLINE_UPGRADE_ACK_T
    *size = 0;
    return REDL_OK;
}

int RedlineManager::HandleGetDevInfo(const gvcp_packet* req, gvcp_packet* ack,
                                     unsigned short /*pkt_id*/, int* size) {
    if (!req || !ack || !size) return REDL_EPARAM;
    // TODO: 填充 rsaVer / encryptedString[1024]
    *size = 0;
    return REDL_OK;
}

int RedlineManager::HandleGetLockInfo(const gvcp_packet* req, gvcp_packet* ack,
                                      unsigned short /*pkt_id*/, int* size, bool /*broadcast*/) {
    if (!req || !ack || !size) return REDL_EPARAM;
    // TODO: 根据 dev_ 状态回填 REDLINE_LOCK_ACK_T
    *size = 0;
    return REDL_OK;
}

int RedlineManager::DefaultActive() {
    std::lock_guard<std::mutex> lk(mtx_);
    // TODO: 默认激活策略（如出厂恢复）
    return REDL_OK;
}