#include "thread_plugin.h"
#include <iostream>
#include <fstream>
#include <sstream>
#include <string>
#include <vector>
#include <dirent.h>    // For opendir, readdir, closedir
#include <unistd.h>    // For sysconf, getpid
#include <algorithm>   // For std::sort, std::min
#include <iomanip>     // For std::fixed, std::setprecision in main (not directly here)
#include <sys/stat.h>  // For checking if path is directory
#include <sys/types.h> // For pid_t


// Helper to convert char state to enum
ThreadState ThreadPlugin::char_to_thread_state(char c) {
    switch (c) {
        case 'R': return ThreadState::RUNNING;
        case 'S': return ThreadState::SLEEPING;
        case 'D': return ThreadState::DISK_SLEEP;
        case 'Z': return ThreadState::ZOMBIE;
        case 'T': return ThreadState::TRACED_STOPPED;
        case 't': return ThreadState::TRACED_STOPPED; // Also seen as 't' (tracing stop)
        case 'W': return ThreadState::PAGING;
        case 'X': return ThreadState::DEAD;
        case 'I': return ThreadState::IDLE;
        default:  return ThreadState::UNKNOWN;
    }
}

// Helper to convert int policy to enum
SchedulingPolicy ThreadPlugin::int_to_sched_policy(int p) {
    switch (p) {
        case 0: return SchedulingPolicy::SCHED_OTHER;
        case 1: return SchedulingPolicy::SCHED_FIFO;
        case 2: return SchedulingPolicy::SCHED_RR;
        case 3: return SchedulingPolicy::SCHED_BATCH;
        // case 4: SCHED_ISO (deprecated)
        case 5: return SchedulingPolicy::SCHED_IDLE;
        case 6: return SchedulingPolicy::SCHED_DEADLINE;
        default: return SchedulingPolicy::UNKNOWN;
    }
}


std::string ThreadInfo::state_to_string() const {
    switch (state) {
        case ThreadState::RUNNING: return "R (Running)";
        case ThreadState::SLEEPING: return "S (Sleeping)";
        case ThreadState::DISK_SLEEP: return "D (Disk Sleep)";
        case ThreadState::ZOMBIE: return "Z (Zombie)";
        case ThreadState::TRACED_STOPPED: return "T (Traced/Stopped)";
        case ThreadState::PAGING: return "W (Paging)";
        case ThreadState::DEAD: return "X (Dead)";
        case ThreadState::IDLE: return "I (Idle)";
        default: return "Unknown";
    }
}

std::string ThreadInfo::policy_to_string() const {
    switch (policy) {
        case SchedulingPolicy::SCHED_OTHER: return "SCHED_OTHER";
        case SchedulingPolicy::SCHED_FIFO: return "SCHED_FIFO";
        case SchedulingPolicy::SCHED_RR: return "SCHED_RR";
        case SchedulingPolicy::SCHED_BATCH: return "SCHED_BATCH";
        case SchedulingPolicy::SCHED_IDLE: return "SCHED_IDLE";
        case SchedulingPolicy::SCHED_DEADLINE: return "SCHED_DEADLINE";
        default: return "Unknown";
    }
}

ThreadPlugin::ThreadPlugin() {
    clock_ticks_per_second_ = sysconf(_SC_CLK_TCK);
    if (clock_ticks_per_second_ <= 0) {
        clock_ticks_per_second_ = 100; // Default if sysconf fails
        // Consider logging an error here
    }
}

ThreadPlugin::~ThreadPlugin() {}

std::string ThreadPlugin::read_file_to_string(const std::string& path) {
    std::ifstream ifs(path);
    if (!ifs.is_open()) {
        return ""; // Or throw an exception
    }
    std::string content((std::istreambuf_iterator<char>(ifs)), std::istreambuf_iterator<char>());
    // Remove trailing newline if exists
    if (!content.empty() && content.back() == '\n') {
        content.pop_back();
    }
    return content;
}

std::vector<std::string> ThreadPlugin::split_string(const std::string& s, char delimiter) {
    std::vector<std::string> tokens;
    std::string token;
    std::istringstream tokenStream(s);
    while (std::getline(tokenStream, token, delimiter)) {
        tokens.push_back(token);
    }
    return tokens;
}

double ThreadPlugin::get_process_uptime_seconds(long process_start_jiffies) {
    std::string uptime_str = read_file_to_string("/proc/uptime");
    if (uptime_str.empty()) return 0.0;

    std::istringstream iss(uptime_str);
    double system_uptime_seconds;
    iss >> system_uptime_seconds; // First value is system uptime

    if (clock_ticks_per_second_ <= 0) return 0.0; // Avoid division by zero

    double process_start_seconds = static_cast<double>(process_start_jiffies) / clock_ticks_per_second_;
    double process_uptime = system_uptime_seconds - process_start_seconds;
    
    return process_uptime > 0.0 ? process_uptime : 0.0; // Ensure non-negative
}


std::pair<std::vector<ThreadInfo>, AggregateStats> ThreadPlugin::flush() {
    std::vector<ThreadInfo> all_threads_info;
    AggregateStats stats = {0};
    pid_t current_pid = getpid(); // Get current process ID

    std::string proc_task_path = "/proc/self/task/"; // For current process

    // Get process start time (jiffies) for CPU % calculation
    // Field 22 in /proc/self/stat
    long process_start_jiffies = 0;
    std::string self_stat_path = "/proc/self/stat";
    std::string self_stat_content = read_file_to_string(self_stat_path);
    if (!self_stat_content.empty()) {
        std::vector<std::string> stat_parts = split_string(self_stat_content, ' ');
        if (stat_parts.size() > 21) { // Field 22 is index 21
            try {
                process_start_jiffies = std::stoll(stat_parts[21]);
            } catch (const std::exception& e) {
                // Handle conversion error if necessary
            }
        }
    }
    double process_uptime_sec = get_process_uptime_seconds(process_start_jiffies);


    DIR* dp = opendir(proc_task_path.c_str());
    if (!dp) {
        // std::cerr << "Error: Could not open " << proc_task_path << std::endl;
        return std::make_pair(all_threads_info, stats);
    }

    struct dirent* entry;
    while ((entry = readdir(dp)) != NULL) {
        if (entry->d_type == DT_DIR) { // Check if it's a directory
            std::string tid_str = entry->d_name;
            if (tid_str == "." || tid_str == "..") continue;

            int32_t tid = 0;
            try {
                tid = std::stoi(tid_str);
            } catch (const std::exception& e) {
                continue; // Not a valid TID directory
            }

            ThreadInfo current_thread = {}; // Initialize with defaults
            current_thread.id = tid;

            // 1. Base Info
            current_thread.name = read_file_to_string(proc_task_path + tid_str + "/comm");
            
            // Parse /proc/[pid]/task/[tid]/stat
            std::string stat_path = proc_task_path + tid_str + "/stat";
            std::string stat_content = read_file_to_string(stat_path);
            if (!stat_content.empty()) {
                // Format: tid (comm) state ppid pgrp session ...
                // Find first ')' to get past comm, then split
                size_t first_paren_close = stat_content.find(')');
                if (first_paren_close != std::string::npos && first_paren_close + 2 < stat_content.length()) {
                    std::string post_comm_stat = stat_content.substr(first_paren_close + 2);
                    std::vector<std::string> stat_fields = split_string(post_comm_stat, ' ');
                    
                    // Fields are 0-indexed after splitting post_comm_stat
                    if (stat_fields.size() > 0) current_thread.state = char_to_thread_state(stat_fields[0][0]); // state (char)
                    // Indices below are relative to fields in /proc/[pid]/stat documentation,
                    // adjusted for our split starting after (comm)
                    // field 3 is state (already got)
                    // field 14 (index 13-2=11 in `stat_fields`) is utime
                    // field 15 (index 14-2=12 in `stat_fields`) is stime
                    // field 18 (index 17-2=15 in `stat_fields`) is priority
                    // field 19 (index 18-2=16 in `stat_fields`) is nice
                    if (stat_fields.size() > 16) { // Ensure enough fields
                        try {
                            uint64_t utime_jiffies = std::stoull(stat_fields[13-2]);
                            uint64_t stime_jiffies = std::stoull(stat_fields[14-2]);
                            current_thread.runtime_user_ms = (utime_jiffies * 1000) / clock_ticks_per_second_;
                            current_thread.runtime_system_ms = (stime_jiffies * 1000) / clock_ticks_per_second_;

                            if (process_uptime_sec > 0.001) { // Avoid division by zero or tiny uptime
                                double thread_user_sec = static_cast<double>(utime_jiffies) / clock_ticks_per_second_;
                                double thread_system_sec = static_cast<double>(stime_jiffies) / clock_ticks_per_second_;
                                current_thread.cpu_usage_user_avg_percent = (thread_user_sec / process_uptime_sec) * 100.0;
                                current_thread.cpu_usage_system_avg_percent = (thread_system_sec / process_uptime_sec) * 100.0;
                            } else {
                                current_thread.cpu_usage_user_avg_percent = 0.0;
                                current_thread.cpu_usage_system_avg_percent = 0.0;
                            }


                            current_thread.priority = std::stol(stat_fields[17-2]);
                            current_thread.nice_value = std::stol(stat_fields[18-2]);
                        } catch (const std::exception& e) { /* Parsing error */ }
                    }
                }
            }

            // Parse /proc/[pid]/task/[tid]/status
            std::string status_path = proc_task_path + tid_str + "/status";
            std::string status_content = read_file_to_string(status_path);
            if (!status_content.empty()) {
                std::istringstream status_stream(status_content);
                std::string line;
                while (std::getline(status_stream, line)) {
                    if (line.rfind("VmStk:", 0) == 0) { // Starts with VmStk:
                        try {
                            current_thread.memory_stack_kb = std::stoull(line.substr(line.find_first_of("0123456789")));
                        } catch (const std::exception& e) { /* Parsing error */ }
                    } else if (line.rfind("voluntary_ctxt_switches:", 0) == 0) {
                        try {
                            current_thread.voluntary_context_switches = std::stoull(line.substr(line.find_first_of("0123456789")));
                        } catch (const std::exception& e) { /* Parsing error */ }
                    } else if (line.rfind("nonvoluntary_ctxt_switches:", 0) == 0) {
                        try {
                            current_thread.nonvoluntary_context_switches = std::stoull(line.substr(line.find_first_of("0123456789")));
                        } catch (const std::exception& e) { /* Parsing error */ }
                    }
                }
            }
            
            // Parse /proc/[pid]/task/[tid]/sched for scheduling policy
            std::string sched_path = proc_task_path + tid_str + "/sched";
            std::string sched_content = read_file_to_string(sched_path);
             if (!sched_content.empty()) {
                std::istringstream sched_stream(sched_content);
                std::string line;
                // First line usually is "thread_name (tid, policy prio)"
                // e.g. my_thread (12345, 0) or other_thread (12346, 0)
                // A more robust way would be to look for "policy" line if available or parse based on known constants
                // For simplicity here, we assume it's on the first line or we get it from /stat.
                // The /proc/[pid]/stat field 40 (index 39) `policy` is more reliable on newer kernels.
                // For older kernels, you may need to map from /proc/[pid]/sched constants.
                // As of Linux 5.x, `/proc/[pid]/task/[tid]/stat` field 39 (policy) is the sched policy.
                // Let's try to get it from stat_fields (field index 38 if comm is removed)
                // Or, typically the policy is also printed in the first line of /proc/TID/sched as "TID (policy)"
                // Example: "bash (31366, #threads: 1)
                // -------------------------------------------------------------------
                // policy: 0" (This would be better)
                 while (std::getline(sched_stream, line)) {
                    if (line.rfind("policy", 0) == 0 || line.rfind("Policy", 0) == 0) { // e.g. "policy : 0"
                        size_t colon_pos = line.find(':');
                        if (colon_pos != std::string::npos) {
                            try {
                                int policy_val = std::stoi(line.substr(colon_pos + 1));
                                current_thread.policy = int_to_sched_policy(policy_val);
                                break; 
                            } catch (const std::exception& e) { /* parsing error */ }
                        }
                    }
                 }
                 if (current_thread.policy == SchedulingPolicy::UNKNOWN && !stat_content.empty()) {
                    // Fallback to /stat field 39 (index 38 after (comm) split) if /sched parse failed
                    // This field index can vary. On a 5.4 kernel, it's field 41 (index 40)
                    // Let's assume it's field 39 for older kernels as a fallback
                    std::vector<std::string> stat_fields = split_string(stat_content.substr(stat_content.find(')') + 2), ' ');
                    if (stat_fields.size() > 38) { // Check if field 39 (index 38) exists
                        try {
                            current_thread.policy = int_to_sched_policy(std::stoi(stat_fields[38]));
                        } catch (const std::exception &e) { /* parsing error */ }
                    }
                }
            }


            // Open File Descriptors
            std::string fd_path = proc_task_path + tid_str + "/fd/";
            DIR* fddp = opendir(fd_path.c_str());
            int fd_count = 0;
            if (fddp) {
                struct dirent* fd_entry;
                while ((fd_entry = readdir(fddp)) != NULL) {
                    if (std::string(fd_entry->d_name) != "." && std::string(fd_entry->d_name) != "..") {
                        fd_count++;
                    }
                }
                closedir(fddp);
            }
            current_thread.open_files_count = fd_count;

            // Wchan (blocking channel)
            current_thread.wchan = read_file_to_string(proc_task_path + tid_str + "/wchan");
            if (current_thread.wchan == "0") current_thread.wchan = "Not Blocking / N/A";


            // Call Stack (Placeholder - very complex to get reliably for other threads)
            current_thread.call_stack.push_back("Call stack retrieval is complex and OS-dependent.");
            current_thread.call_stack.push_back("Requires ptrace, libunwind, or similar mechanisms.");


            all_threads_info.push_back(current_thread);
        }
    }
    closedir(dp);

    // --- Aggregate Analysis ---
    stats.total_threads = all_threads_info.size();
    for (const auto& t_info : all_threads_info) {
        stats.threads_by_state[t_info.state]++;
    }

    // CPU Hot Threads (sort by total runtime_ms)
    std::vector<ThreadInfo> sorted_threads = all_threads_info;
    std::sort(sorted_threads.begin(), sorted_threads.end(), 
        [](const ThreadInfo& a, const ThreadInfo& b) {
            return (a.runtime_user_ms + a.runtime_system_ms) > (b.runtime_user_ms + b.runtime_system_ms);
    });

    size_t hot_thread_count = std::min(size_t(5), sorted_threads.size()); // Top 5
    for (size_t i = 0; i < hot_thread_count; ++i) {
        if ((sorted_threads[i].runtime_user_ms + sorted_threads[i].runtime_system_ms) > 0) { // Only if has consumed CPU
            stats.cpu_hot_thread_ids.push_back(sorted_threads[i].id);
        }
    }
    
    return std::make_pair(all_threads_info, stats);
}
