/**
 * @brief      将json数据原子保存至文件
 * @param[in]  file_path 保存文件的路径
 * @param[in]  root json数据的根节点
 * @return     成功:0.失败:相应的错误号(负值)
 */
int32_t save_json_into_file_atomic(const char *file_path, cJSON *root)
{
	int32_t fd = -1;
	int32_t dirfd = -1;
	int32_t fsize = 0;
	int32_t ret = 0;
	int32_t error = 0;
	char *disp_str = NULL;
	char *tmp_path = NULL;
	char *dir_path_buf = NULL;
	const char *dir_path = ".";
	int renamed = 0;

	if ((NULL == file_path) || (NULL == root))
	{
		LOGE("[%s] path or js_root is null\n", __func__);
		LEAVE(SC_EC_NULLPTR, out);
	}

	tmp_path = (char *)malloc(strlen(file_path) + sizeof(".tmpXXXXXX"));
	if (NULL == tmp_path)
	{
		LOGE("[%s] malloc tmp path fail\n", __func__);
		LEAVE(SC_EC_MALLOC, out);
	}
	snprintf(tmp_path, strlen(file_path) + sizeof(".tmpXXXXXX"), "%s.tmpXXXXXX", file_path);

	fd = mkstemp(tmp_path);
	if (fd < 0)
	{
		LOGE("[%s] mkstemp %s error\n", __func__, tmp_path);
		LEAVE(SC_EC_OPEN, out);
	}
	(void)fchmod(fd, 0777);

	disp_str = cJSON_Print(root);
	if (NULL == disp_str)
	{
		LOGE("failed to cJSON_Print\n");
		LEAVE(SC_EC_NULLPTR, out);
	}

	fsize = strlen(disp_str);
	if ((ret = write(fd, disp_str, fsize)) != fsize)
	{
		LOGE("write file %s error:\n", tmp_path);
		LEAVE(SC_EC_WRITE, out);
	}

	if (fsync(fd) < 0)
	{
		LOGE("sync file %s error:\n", tmp_path);
		LEAVE(SC_EC_READ, out);
	}

	if (close(fd) < 0)
	{
		fd = -1;
		LEAVE(SC_EC_READ, out);
	}
	fd = -1;

	if (rename(tmp_path, file_path) < 0)
	{
		LOGE("rename %s to %s error:\n", tmp_path, file_path);
		LEAVE(SC_EC_RENAME, out);
	}
	renamed = 1;

	{
		const char *slash = strrchr(file_path, '/');
		if (slash)
		{
			size_t dir_len = (size_t)(slash - file_path);
			dir_path_buf = (char *)malloc(dir_len + 1);
			if (NULL == dir_path_buf)
			{
				LOGE("[%s] malloc dir path fail\n", __func__);
				LEAVE(SC_EC_MALLOC, out);
			}
			memcpy(dir_path_buf, file_path, dir_len);
			dir_path_buf[dir_len] = '\0';
			dir_path = dir_path_buf;
		}
	}

#ifdef O_DIRECTORY
	dirfd = open(dir_path, O_RDONLY | O_DIRECTORY);
#else
	dirfd = open(dir_path, O_RDONLY);
#endif
	if (dirfd < 0)
	{
		LOGE("[%s] open dir %s error\n", __func__, dir_path);
		LEAVE(SC_EC_OPEN, out);
	}

	if (fsync(dirfd) < 0)
	{
		LOGE("sync dir %s error:\n", dir_path);
		LEAVE(SC_EC_READ, out);
	}

out:
	if (fd >= 0)
	{
		close(fd);
	}
	if (dirfd >= 0)
	{
		close(dirfd);
	}
	if (error < 0 && tmp_path && !renamed)
	{
		unlink(tmp_path);
	}
	if (disp_str)
	{
		cJSON_free(disp_str);
	}
	if (tmp_path)
	{
		free(tmp_path);
	}
	if (dir_path_buf)
	{
		free(dir_path_buf);
	}
	return error;
}
