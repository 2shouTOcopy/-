
int RedlineManager::HandleInterchange(const gvcp_packet* req, gvcp_packet* ack,
									  unsigned short pkt_id, int* size, bool broadcast)
{
	int ret = 0;
	size_t outlen = 0;
	unsigned short status = GEV_STATUS_SUCCESS;
	RL_InterchangeCmdView stCmd{};
	RL_InterchangeAckView stAck{};

	if (!req || !ack || !size)
	{
		return REDL_EPARAM;
	}

	if (!RL_ParseInterchangeCmd(req, stCmd))
	{
		return REDL_EPARAM;
	}

	do
	{
		//激活后
		if (DEV_ACTIVATED == GetActiveSts())
		{
			// 广播包，但是mac地址不相等
			if (broadcast && !RedlineUtils::isMacAddressMatch(stCmd.macHigh, stCmd.macLow))
			{
				*size = 0;
				return REDL_OK;
			}

			if (stCmd.mode != REDLINE_ACTIVE)
			{
				LOGE("device actived, and inter mode not auth!\n");
				status = GEV_STATUS_DEVICE_ALREADY_ACTIVE;
				*size = GVCP_HEADER_SIZE;
				break;
			}
			stAck.mode = RL_InterDataMode::Salt_Random;
			memcpy(stAck.salt.data(), m_stSolid.salt[0], RANDOM_SALT_STR_LEN);

			// 读取或者生成盐值，生成随机串A；
			generate_random_string(m_activeRandom, RANDOM_SALT_STR_LEN + 1);
			LOGI("random string :%s!\n", m_activeRandom);

			unsigned char e1[256] = {0};
			ret = generate_e1_encrypt(m_activeRandom, m_stSolid.salt[0], e1, 256, &outlen);
			if (ret != 0 && status != GEV_STATUS_SUCCESS)
			{
				status = GEV_STATUS_REDLINE_API_FAILED;
			}

			char devE1[8 + 1] = {0};
			memset(devE1, 0, sizeof(devE1));
			if (outlen >= 8)
			{
				memcpy(devE1, e1 + outlen - 8, 8);
				memcpy(stAck.devE1.data(), devE1, 8);
			}

			LOGE("new e1 %s; outlen %d! devE1 %s\n", e1, outlen, devE1);
			memcpy(stAck.randomString.data(), m_activeRandom, RANDOM_SALT_STR_LEN);
		}


		else if (DEV_DEACTIVATED == GetActiveSts() || DEV_INIT_STS == GetActiveSts())
		{
			//激活
			if (stCmd.mode != REDLINE_INACTIVE)
			{
				LOGE("device not actived, and inter mode not active!\n");
				status = GEV_STATUS_ACCESS_DENIED;
				*size = GVCP_HEADER_SIZE;
				break;
			}
			else
			{
				stAck.mode = RL_InterDataMode::Encrypt_Random;
				unsigned char rsaPubKey[1024] = {0};

				// 解码拿到公钥
				base64_decode(stCmd.publicKey.data(), rsaPubKey);
				LOGD("pub key decode len %zu; get rsa pub key %s!\n",
					 strlen((const char*) rsaPubKey), rsaPubKey);

				// 生成随机串A；
				unsigned char randomStr[RANDOM_SALT_STR_LEN + 1] = {0};
				generate_random_string(randomStr, RANDOM_SALT_STR_LEN + 1);
				memset(m_activeRandom, 0, sizeof(m_activeRandom));
				memcpy(m_activeRandom, randomStr, RANDOM_SALT_STR_LEN);
				LOGE("random string :%s! m_activeRandom %s, random len %zu\n", randomStr,
					 m_activeRandom, strlen((const char*) randomStr));

				// 使用RSA公钥对随机串进行加密,会直接进行base64编码输出
				ret = rsa_encrypt_by_key(rsaPubKey, randomStr, strlen((const char*) randomStr),
										 stAck.enRandomString.data(), &outlen);
				if (ret != 0)
				{
					LOGE("rsa encrypt failed! ret %d\n", ret);
					status = GEV_STATUS_REDLINE_API_FAILED;
					*size = GVCP_HEADER_SIZE;
					break;
				}
				LOGE("enlen %d , rsa en string :%s \n", outlen, stAck.enRandomString.data());
			}
		}
	} while (0);

	if (GEV_STATUS_SUCCESS == status)
	{
		RL_WriteInterchangeAck(ack, stAck, size);
	}
	RL_GvcpFillAckHeader(&ack->header, status, GVCP_COMMAND_INTERCHANGE_ACK, *size, pkt_id);
	return REDL_OK;
}


int RedlineManager::HandleActive(const gvcp_packet* req, gvcp_packet* ack, unsigned short pkt_id,
								 int* size)
{
	RL_ActiveCmdView stCmd;
	RL_ActiveAckView stAck;
	unsigned char deAesPassword[32] = {0};
	size_t outlen = 0;
	int status = GEV_STATUS_SUCCESS;
	int ret = -1;

	if (!req || !ack || !size)
	{
		return REDL_EPARAM;
	}
	if (GetActiveSts() == DEV_ACTIVATED)
	{
		return REDL_OK;
	}

	if (!RL_ParseActiveCmd(req, stCmd))
	{
		return REDL_EPARAM;
	}

	do
	{
		ret = aes128_cbc_decrypt(m_activeRandom, m_activeRandom, stCmd.enPassword.data(),
								 strlen((const char*) stCmd.enPassword.data()), deAesPassword,
								 &outlen);
		if (ret != 0)
		{
			LOGE("aes128_cbc_decrypt failed! ret %d!\n", ret);
			status = GEV_STATUS_REDLINE_API_FAILED;
			*size = GVCP_HEADER_SIZE;
			break;
		}


		// LOGE("aes decrypt data %s! outlen %d\n", deAesPassword, outlen);
		deAesPassword[outlen] = '\0';

		// 1.3 对密码进行合法性校验，客户端会进行校验，这里再次确认
		if (!checkPasswd((char*)DEFAULT_USER_NAME, (char*) deAesPassword))
		{
			LOGE("password check failed!!\n");
			status = GEV_STATUS_PWD_FMT_INVALID;
			*size = GVCP_HEADER_SIZE;
			break;
		}

		// 1.4 生成盐值，和密码进行En计算
		unsigned char e1[256] = {0};
		unsigned char salt[RANDOM_SALT_STR_LEN + 1] = {0};

		generate_random_string(salt, RANDOM_SALT_STR_LEN + 1);
		LOGE("salt: %s! salt len %zu\n", salt, strlen((const char*) salt));

		ret = generate_e1_encrypt(deAesPassword, salt, e1, 256, &outlen);
		if (ret != 0)
		{
			LOGE("generate_e1_encrypt failed! ret %d!\n", ret);
			status = GEV_STATUS_REDLINE_API_FAILED;
			*size = GVCP_HEADER_SIZE;
			break;
		}

		LOGE("e1 %s; outlen %d!\n", e1, outlen);

		memcpy(m_stSolid.userName[0], DEFAULT_USER_NAME,
			   strlen(DEFAULT_USER_NAME));
		memcpy(m_stSolid.password[0], deAesPassword,
			   strlen((char*) deAesPassword) < PWD_MAX_LENGTH ? strlen((char*) deAesPassword)
															  : PWD_MAX_LENGTH);
		memcpy(m_stSolid.salt[0], salt, strlen((char*) salt));
		memcpy(m_stSolid.e1[0], e1, strnlen((char*) e1, sizeof(m_stSolid.e1[0]) - 1));
		m_stSolid.bActiveSts = 1;  // 0未激活，1已激活，FF异常状态

		// 1.6 将用户名和密码设置给BSP(Uboot和Kernel)
		ret = bsp_set_passwd((const char*) m_stSolid.userName[0],
							 (const char*) m_stSolid.password[0]);
		if (ret != 0)
		{
			LOGE("set bsp passed failed! ret %d!\n", ret);
			status = GEV_STATUS_BSP_SECURE_FAILED;
			*size = GVCP_HEADER_SIZE;
			memset(&m_stSolid, 0, sizeof(m_stSolid));
			break;
		}

		SaveSolidParams();

		memcpy(stAck.salt.data(), salt, RANDOM_SALT_STR_LEN);
	} while (0);

	RL_WriteActiveAck(ack, stAck, size);
	RL_GvcpFillAckHeader(&ack->header, status, GVCP_COMMAND_ACTIVE_ACK, *size, pkt_id);
	return REDL_OK;
}

int RedlineManager::HandleLogin(const gvcp_packet* req, gvcp_packet* ack, unsigned short pkt_id,
								int* size, bool broadcast)
{
	unsigned char myEn[128] = {0};
	unsigned char myAuthEn[128] = {0};
	size_t outEnLen = 0;
	int ret = 0;
	int status = GEV_STATUS_SUCCESS;
	RL_LoginCmdView stCmd{};
	RL_LoginAckView stAck{};
	struct product_data* rt = get_product_data();

	if (!req || !ack || !size)
	{
		return REDL_EPARAM;
	}

	// A/B 互斥：仅允许唯一在线
	if (!TryAcquireSession())
	{
		//return REDL_EBUSY;
	}

	if (!RL_ParseLoginCmd(req, stCmd))
	{
		return REDL_EPARAM;
	}

	struct timeval now;
	struct timeval start;
	RedlineUtils::getCurrentTime(&start);


	do
	{
		if (isLocked_())
		{
			status = GEV_STSTUS_LOCKED_DENIED;
			break;
		}

		LOGE("generate en param e1:%s; random string %s! salt %s\n", m_stSolid.e1[0],
			 m_activeRandom, m_stSolid.salt[0]);

		ret = generate_en_encrypt(m_stSolid.e1[0], m_activeRandom, myEn, 128, &outEnLen);
		if (ret != 0)
		{
			LOGE("generate en failed! ret %d!\n", ret);
			status = GEV_STATUS_REDLINE_API_FAILED;
			break;
		}

		RedlineUtils::getCurrentTime(&now);
		LOGE("auth en cost %dms!\n", RedlineUtils::calcTimeDiff(now, start));

		LOGE("myEn %s, outlen %zu; login En %s!\n", myEn, outEnLen, stCmd.enString);

		if (strncmp((char*) myEn, (char*) stCmd.enString.data(), 64) == 0)
		{
			LOGE("en compare ok!\n");

			if (stCmd.function == LOGIN_CMD_LOGIN)
			{
				RecoverLockInfo();

				m_stDevSts.login_sts1 = LOGGED_IN;
				m_stDevSts.cookie_timeout_sts = 0;
				memcpy(rt->device_configs.SessionCookie, m_activeRandom, RANDOM_SALT_STR_LEN);


				// sc和支持tcp fileaccess的需要生成端口协商；
				stAck.keepAlivePort = htons(rt->device_state.GevHeartBeatPort);
				stAck.fileAccessPort = htons(rt->device_configs.GevPrivCPort);

				memcpy(stAck.cookie.data(), m_activeRandom, RANDOM_SALT_STR_LEN);
				break;
			}
			else if (stCmd.function == LOGIN_CMD_AUTH)
			{
				if (broadcast && !RedlineUtils::isMacAddressMatch(stCmd.macHigh, stCmd.macLow))
				{
					*size = 0;
					return 0;
				}

				RecoverLockInfo();

				m_stDevSts.auth_sts = 1;
				m_stDevSts.cookie_timeout_sts = 0;
				RedlineUtils::getCurrentTime(&m_stDevSts.auth_start_time);

				ret = thread_spawn_ex(&m_thAuthTimeout, 1, SCHED_POLICY_OTHER, SCHED_PRI_NA,
									  10 * 1024, AuthStsTimeoutThread, this);
				if (ret < 0)
				{
					LOGE("login_lock_thread_t creation failed!\r\n");
				}

				break;
			}
		}
		else
		{
			LOGE("en compare failed!\n");

			DoLock();

			status = GEV_STATUS_PWD_VERIFY_FAILED;
			break;
		}
	} while (0);

	if (stCmd.function == LOGIN_CMD_AUTH)
	{
		memcpy(myAuthEn, stCmd.enString.data(), 64);
		myAuthEn[64] = '\0';

		ret = generate_en_encrypt(myAuthEn, m_activeRandom, myEn, 128, &outEnLen);
		if (ret != 0)
		{
			LOGE("generate en failed! ret %d!\n", ret);
			status = GEV_STATUS_REDLINE_API_FAILED;
		}
	}

	char devEn[8 + 1];

	memset(devEn, 0, sizeof(devEn));
	if (outEnLen >= 8)
	{
		memcpy(devEn, myEn + outEnLen - 8, 8);
		memcpy(stAck.devEn.data(), devEn, 8);
	}

	LOGE("dev en %s, login ack en %s!\n", devEn, myEn);

	RL_WriteLoginAck(ack, stAck, size);

	RedlineUtils::getCurrentTime(&now);
	LOGE("after proc cost %dms!\n", RedlineUtils::calcTimeDiff(now, start));

	RL_GvcpFillAckHeader(&ack->header, status, GVCP_COMMAND_LOGIN_ACK, *size, pkt_id);
	return REDL_OK;
}

	REDLINE_SOLIDIFY_PARAM_T m_stSolid{};
	REDLINE_DEVICE_STS_T m_stDevSts{};

/*相机红线固化保存数据*/
typedef struct
{
    uint8_t userName[8][16];  // 默认最多支持8个用户，用户0默认为管理员
    uint8_t password[8][16];
    uint8_t salt[8][20];  // 8个盐值，跟用户名一一对应
    uint8_t e1[8][68];	  // 8个e1，跟用户名一一对应
    uint8_t bActiveSts;	  // 设备激活状态，激活或者去激活时写入，上电读取
    uint32_t reserved2[32];	 // 保留参数
} REDLINE_SOLIDIFY_PARAM_T;

typedef struct
{
    int login_sts1;
    int login_times;  // 同一个用户名尝试登录次数，若是超过五次失败，锁定时间到了之后恢复
    int auth_sts;  // 鉴权标志位，修改IP鉴权完成之后，置为1，有效期3分钟，3分钟之后置0
    int cookie_timeout_sts;	 // cookie超时状态，提示需要回复鉴权
    int upg_auth;			 // 升级鉴权状态
    uint8_t lock_sts;		 // 锁定状态
    uint8_t reserved1;
    uint16_t lock_times;  // 剩余锁定时间
    struct timeval lock_start_time;
    struct timeval auth_start_time;
} REDLINE_DEVICE_STS_T;


