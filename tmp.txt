# 鉴权方案用到的密码学组件概览

- **RSA3072（非对称加密）**
  - 用途：激活时，用客户端公钥加密随机串 A
  - 解决问题：在还没有共享密钥之前，安全协商出一串随机密钥 A
  - 特点：客户端独占私钥，只有客户端能解开 A

- **AES128-CBC（对称加密）**
  - 用途：
    - 激活时加密“用户设置的密码”（密文 C）
    - 密码修改 / 重置时加密“新密码 + 随机串”
  - 解决问题：在已经有共享密钥（随机串 A 或派生密钥）的前提下，安全传输明文密码

- **SHA256（摘要算法）**
  - 用途：
    - 生成密码指纹：`E1 = f(salt, password)`
    - 登录 / RESTORE / FORCEIP / 升级等流程里的 `En = f(A, E1)`
    - 密码重置中生成重置口令、派生 AES 密钥
  - 解决问题：不可逆存储 / 验证密码，以及“挑战-应答”式口令证明（防重放）

- **盐值 salt（随机 16 字节）**
  - 用途：和密码一起参与 E1 计算
  - 解决问题：
    - 相同密码在不同设备/用户下得到不同 E1
    - 分区泄露后，提高离线撞库门槛（防彩虹表）

> 激活前：RSA + AES 先把“秘密”安全建立起来  
> 激活后：salt + E1 + En 负责长期安全存储和每次登录的挑战-应答验证


---

# 激活流程设计：从无密到有密

## 阶段一：用 RSA 搭建安全通道

1. 客户端生成 RSA3072 公私钥 → 公钥 base64 发给设备（`INTERCHANGE_CMD`，Mode=1）
2. 设备：
   - base64 解码拿到公钥
   - 生成随机串 **A**
   - 用公钥对 A 做 RSA 加密 → 得到加密串 B → base64 → 放到 `INTERCHANGE_ACK.Random string`
3. 客户端用私钥解密 B，拿回随机串 A

> 目的：只让真正握有私钥的客户端知道 A，建立起一个共享密钥 A。

## 阶段二：用 AES 传输激活密码

1. 客户端用 A 作为 AES128-CBC 的 key & iv，加密“用户密码” → C  
2. C base64 后放入 `ACTIVE_CMD.Encrypted string`（24B）  
3. 设备收到 `ACTIVE_CMD`：
   - 先 base64 解码 C
   - 用 A 解 AES128-CBC，得到明文密码

> 目的：让设备在不暴露密码给网络的前提下，拿到明文做复杂合法性校验（长度 ≥ 8，至少 2 类字符等）。

## 阶段三：用 SHA256 + salt 做长期存储

1. 设备生成随机 `salt[16]`
2. 计算 E1（示意）：

   ```text
   E1 = SHA256(salt || password)

	3.	把 salt + E1 写入固化分区（REDLINE_SOLIDIFY_PARAM_T）
	4.	激活成功后，只保留 salt + E1，不再持久化明文密码

目的：本地不存明文，只存密码指纹，防止分区被拷走后直接泄露密码。

激活流程时序示意（可做简图）

Client:  RSA keypair -> PubKey(Base64) --------------------> Device
Device:  A = random()
         B = RSA(PubKey, A)
         INTERCHANGE_ACK(Random string = Base64(B)) -------> Client
Client:  A = RSA_Decrypt(PrivKey, B)
         C = AES128_CBC_Enc(key=A, iv=A, pwd)
         ACTIVE_CMD(Encrypted string = Base64(C)) ---------> Device
Device:  pwd  = AES128_CBC_Dec(key=A, iv=A, C)
         salt = random16()
         E1   = SHA256(salt || pwd)
         保存 salt + E1，激活完成


⸻

激活后的交换码 & 登录：En + cookie 机制

激活后 INTERCHANGE（Mode=2）
	1.	客户端在 INTERCHANGE_CMD 里带上用户名发送给设备
	2.	设备：
	•	根据用户名读取对应 salt
	•	生成随机串 A（本次会话 challenge）
	•	在 INTERCHANGE_ACK 中返回：
	•	Salt[16]（明文）
	•	Random string = A（明文 16B）
	•	Random E1：设备用随机串 A + 盐对 E1 再算一次摘要（取 8 字节），供客户端校验一致性

此时 Random string 改为明文是安全的：真正的秘密在 E1 + password，A 只是一次性挑战。

登录（LOGIN）通用模板
	1.	客户端拿到 salt + A
	2.	客户端计算本地 E1 / En（示意）：

E1 = SHA256(salt || password)   // 激活时约定好的 E1
En = SHA256(A || E1)            // 本次挑战-应答摘要


	3.	客户端在 LOGIN_CMD.En string 里带上 En 发给设备
	4.	设备端：
	•	从分区读出存储的 E1
	•	自己算一遍 En' = SHA256(A || E1)
	•	比较 En' 与 En：
	•	相等 → 密码正确，登录通过
	•	不等 → 失败计数 + 可能锁定（Login Fail Times / Remain Login attempts）

设备永远不需要密码明文，只要比较 En 是否正确。

En 方案的安全性要点
	•	网络侧可见：A、salt、En
	•	不可见：password、E1
	•	想猜密码，攻击者必须暴力枚举 password，每次都走完整 SHA256 链路
	•	每次登录 A 都不同 → 抓包重放只对那一次有效，下一次完全不同

Cookie 的角色
	•	LOGIN_ACK.Cookie[16]：会话标识
	•	文档：会话标识（通交换码阶段的随机串），有效期 5–60 分钟
	•	实际上就是这次交换码产生的 A：
	•	先作为 challenge 用于 En 计算
	•	登录成功后，作为 cookie 代表本次会话 ID，用于后续参数/寄存器操作

激活后所有敏感操作前，都先“交换码”：拿到 salt + A，用 En 证明“我知道密码”；
登录成功后，用 A 延续成 cookie，减少重复输入密码，但有时间窗约束。

⸻

多指令共用的一套鉴权模板

密码修改（CHANGEPWD）示例
	1.	客户端提示用户输入：用户名 + 旧密码 + 新密码
	2.	客户端发起 INTERCHANGE_CMD（Mode=2），拿到 salt + A
	3.	客户端计算：
	•	En1：基于 A + 旧密码的摘要（证明旧密码正确）
	•	B ：AES128_CBC_Enc(key=A, iv=A, plaintext=新密码) → Base64(B)
	4.	CHANGEPWD_CMD 同时携带：
	•	En1 string [64B] （旧密码 En1）
	•	Encrypted string [24B]（新密码密文 B）
	5.	设备端处理：
	•	用本地 E1 + A 计算 En1'，与 En1 比较（旧密码验证）
	•	解 AES 得到新密码明文，做复杂合法性校验
	•	生成新 salt，对新密码做新的 E1，写回分区

同时保证：旧密码合法性 + 新密码安全传输。

恢复未激活（RESTORE）
	•	模板同上，但目标是“清空密码/用户名/盐值，置为未激活”
	•	流程：
	•	先 INTERCHANGE 拿 salt + A
	•	客户端用密码算 En
	•	设备用存储的 E1 算 En’ 对比
	•	通过后：
	•	清空用户名、密码、盐值
	•	置未激活状态
	•	删除 u-boot / kernel 密码（SSH 默认不可用）

FORCEIP / 升级（UPGRADE）
	•	FORCEIP：
	•	激活后修改 IP 前，必须先通过“交换码 + En”鉴权（支持单播 / 广播）
	•	鉴权通过后，再走原有 FORCEIP 流程
	•	UPGRADE：
	•	UPGRADE_CMD 中同时带上：
	•	升级数据端口 port
	•	En string（密码 En 摘要）
	•	设备用 E1 + A 验证 En
	•	验证通过后允许升级，然后走原有升级主流程（8000 端口），外加升级包解密和验签

上述命令都复用模板：
先交换码 → salt + A → En 验证 → 验证通过后才能执行敏感操作（改密 / 清零 / 改 IP / 升级）。

⸻

密码重置流程：防滥用的多方参与设计

设计目标
	•	忘记密码时，提供一个“可控的重置通道”
	•	防止任何一方（用户 / 单台设备）单方面绕过重置机制
	•	OA、设备、客户端三方参与，才能成功重置

阶段一：生成设备码（GETDEVINFO）
	1.	客户端发 GETDEVINFO_CMD
	2.	设备：
	•	组合设备码 A（TLV，包含序列号、随机数等）
	•	用内置公钥[1] 对 A 做 RSA 加密 → encryptedstring
	•	封装 TLV1 + Base64，拼接序列号，生成密码重置文件 C

设备只存公钥[1]，私钥[1] 仅在 OA 上，设备自己无法直接算出重置口令。

阶段二：OA 计算重置口令
	1.	OA 端解码文件 C，恢复设备码 A
	2.	对 A 做 SHA256，取前 8 字节作为“重置口令”（8 位）
	3.	技术支持拿该重置口令给用户使用

阶段三：客户端 + 设备用 SHA256 派生 AES 密钥，安全传新密码
	1.	客户端：
	•	用户输入“重置口令”
	•	生成随机串 D
	•	计算：K = 前16字节(SHA256(D + 重置口令))
	•	用 AES128_CBC(key=K, iv=D) 加密 (D + 新密码) → F
	•	F Base64 → G，连同 D 发 RESETPWD_CMD
	•	Encrypt string[64B] = G
	•	random string[32B] = D
	2.	设备：
	•	自行计算重置口令（对内部 32 字节随机数做 SHA256，取前 8 字节）
	•	计算同样的 K' = 前16字节(SHA256(D + 重置口令))
	•	用 K' 解密 G → 得到 D' + 新密码
	•	校验 D' == D
	•	对新密码进行 En/E1 计算，更新分区

再次联合使用：SHA256（派生 K、计算重置口令）+ AES（传输新密码明文），同时要求 OA 参与。

设备码有效期与使用限制（摘要）
	•	重复获取（同一次交互）不刷新设备码；
	•	超过 24 小时未进行重置操作 → 设备码失效（基于 uptime 计算，不受校时影响）；
	•	实际触发重置（成功或失败）后，设备码立即失效，仅一次有效；
	•	设备掉电重启，设备码失效。

“忘记密码重置”被设计成一个有审计、有时效、一次性的流程，符合安全红线要求。

⸻

从协议设计到安全红线落地（总结页）

不传明文、不存明文
	•	协议层：
	•	激活 / 改密 / 重置：密码传输统一走 AES128-CBC
	•	登录 / RESTORE / FORCEIP / UPGRADE：只上传 En，不传密码
	•	存储层：
	•	分区只保存 salt + E1，不保存明文密码

防重放、防假登录
	•	每次交换码都有新的随机串 A
	•	登录 / 恢复 / FORCEIP / 升级都用 En(A, E1) 做挑战-应答
	•	Cookie 有失效时间（5–60 分钟），会话过期需重新登录

密码操作有严格安全边界
	•	修改密码：必须提供旧密码的 En1
	•	重置密码：必须有 OA 生成的重置口令 + 设备码 + 有效期控制
	•	恢复未激活：必须在“激活且未连接”状态下，通过 En 验证后执行

敏感操作全部前置鉴权
	•	FORCEIP、固件升级、参数操作（Write/Read reg）都挂在鉴权之后
	•	会话 ID（cookie）写入寄存器，做二次校验和超时控制

整个 PD-001 实际上就是把“不传明文、不存明文、防重放、重置可控”这些安全红线，
写进了每一条指令、每一个字段和每一次加解密调用里。

