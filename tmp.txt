#include <deque>
#include <memory> // For std::shared_ptr
#include <mutex>
#include <condition_variable>
#include <atomic>
#include <thread>
#include <cstring> // For std::strncpy, std::strlen if needed
#include <cmath>   // For std::isnan / NAN

// --- 假设的 PluginService 和 value_list_t (为了使示例可编译和运行) ---
// 在您的项目中，这些应该是您实际的定义
namespace PluginService {
    // 假设的 value_list_t 定义
    struct value_list_t {
        // 您的 value_list_t 实际成员
        // 例如:
        double values[1]; // 假设它包含一个值
        long long timestamp;

        value_list_t() : timestamp(0) { values[0] = 0.0; } // 默认构造
    };

    // 假设的 PluginService 定义
    class Instance {
    public:
        static Instance& get() { // 通常用 get() 或 Instance()
            static Instance inst;
            return inst;
        }
        void write(const data_set_t* ds, const value_list_t* vl) {
            // 这是一个模拟的实现
            printf("PluginService::write called for ds.type: %s\n", ds->type);
            if (ds->ds_num > 0 && ds->ds) {
                const char* type_str = "UNKNOWN_TYPE";
                if (ds->ds[0].type == DS_TYPE_DERIVE) type_str = "DERIVE";
                else if (ds->ds[0].type == DS_TYPE_GAUGE) type_str = "GAUGE";
                // ... 其他类型

                printf("  Data Source[0]: name='%s', type=%d (%s), min=%.1f, max=",
                       ds->ds[0].name, ds->ds[0].type, type_str, ds->ds[0].min);
                if (std::isnan(ds->ds[0].max)) {
                    printf("U (NAN)\n");
                } else {
                    printf("%.1f\n", ds->ds[0].max);
                }
            }
            if (vl) {
                printf("  ValueList provided (e.g., vl->values[0] = %.2f, timestamp = %lld)\n", vl->values[0], vl->timestamp);
            }
             printf("--------------------------------------------------\n");
        }
    private:
        Instance() = default;
    };
} // namespace PluginService

// 假设 RstDispatcher 在一个命名空间内，或者是一个类
// 这里为了简化，我直接定义 Impl
namespace RstDispatcher { // 示例命名空间

struct Impl
{
    std::deque<std::shared_ptr<PluginService::value_list_t>> queue;
    std::mutex              mtx;
    std::condition_variable cv;
    std::atomic<bool>       exit{false};
    std::thread             th;

    // 为 "cpu value:DERIVE:0:U" 这组静态元数据添加成员变量
    data_set_t      m_static_cpu_ds;
    data_source_t   m_static_cpu_data_sources[1]; // 因为 "cpu value:DERIVE:0:U" 只有一个数据源

    Impl()
    {
        // --- 在构造函数中一次性初始化静态元数据 ---
        // 1. 填充 m_static_cpu_ds.type
        std::strncpy(m_static_cpu_ds.type, "cpu", DATA_MAX_NAME_LEN - 1);
        m_static_cpu_ds.type[DATA_MAX_NAME_LEN - 1] = '\0'; // 保证空字符结尾

        // 2. 设置 m_static_cpu_ds.ds_num
        m_static_cpu_ds.ds_num = 1; // 对应 "value:DERIVE:0:U" 这一个数据源

        // 3. 将 m_static_cpu_ds.ds 指向内部的成员数组 m_static_cpu_data_sources
        // 这样就无需在堆上分配内存 (即不用 malloc/new)
        m_static_cpu_ds.ds = m_static_cpu_data_sources;

        // 4. 填充 m_static_cpu_data_sources 数组的元素
        //    对应 "value:DERIVE:0:U"
        //    m_static_cpu_data_sources[0] 是唯一的元素
        std::strncpy(m_static_cpu_data_sources[0].name, "value", DATA_MAX_NAME_LEN - 1);
        m_static_cpu_data_sources[0].name[DATA_MAX_NAME_LEN - 1] = '\0';

        m_static_cpu_data_sources[0].type = DS_TYPE_DERIVE; // 使用枚举值

        m_static_cpu_data_sources[0].min = 0.0;

        // 'U' 通常表示未定义或无限制，使用 NAN (Not a Number)
        // 需要 #include <cmath>
        m_static_cpu_data_sources[0].max = NAN;
        // --- 静态元数据初始化完毕 ---


        th = std::thread([this]{
            /* 若有 thread_set_name，可以在此调用 */
            // 例如: pthread_setname_np(pthread_self(), "RstDispatchTh"); (需要相应头文件和平台支持)
            while (!exit.load(std::memory_order_acquire))
            {
                std::shared_ptr<PluginService::value_list_t> vl_ptr; // 从队列中获取的共享指针
                {
                    std::unique_lock<std::mutex> lk(mtx);
                    // 在等待时，检查退出标志或队列非空
                    // memory_order_relaxed 对于 exit 在 predicate 中通常是安全的，因为lk的加锁解锁会提供必要的屏障
                    cv.wait(lk, [this]{ return exit.load(std::memory_order_relaxed) || !queue.empty(); });

                    // 再次检查退出条件，特别是在被唤醒后
                    // memory_order_acquire 用于确保看到 exit 的最新值以及其他线程的相关修改
                    if (exit.load(std::memory_order_acquire) && queue.empty()) {
                        break; // 退出循环
                    }
                    if (queue.empty()) { // 如果是因为exit被唤醒但队列仍空，则不处理
                        continue;
                    }

                    vl_ptr = std::move(queue.front());
                    queue.pop_front();
                }

                /* todo: 过滤链钩子占位 */

                /* 分发给所有 writer 插件 */
                // 使用预先初始化好的 m_static_cpu_ds 成员
                // vl_ptr->get() 如果 PluginService::Instance().write 需要原始指针
                // 如果 PluginService::Instance().write 可以接受 const std::shared_ptr<value_list_t>&，则直接传递 vl_ptr
                PluginService::Instance::get().write(&this->m_static_cpu_ds, vl_ptr.get());
            }
        });
    }

    ~Impl()
    {
        exit.store(true, std::memory_order_release); // 通知线程退出
        cv.notify_all(); // 唤醒等待的线程
        if (th.joinable())
        {
            th.join(); // 等待线程结束
        }
        // m_static_cpu_ds 和 m_static_cpu_data_sources 是类成员,
        // 它们的内存在 Impl 对象销毁时自动回收，无需手动 free。
    }
};

} // namespace RstDispatcher
