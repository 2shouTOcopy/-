#include <stdio.h>
#include <stdlib.h> // For malloc, free
#include <string.h> // For strncpy
#include <math.h>   // For NAN (Not a Number), representing 'U'

// 假设 DATA_MAX_NAME_LEN 已经定义，例如：
#ifndef DATA_MAX_NAME_LEN
#define DATA_MAX_NAME_LEN 64
#endif

// 您的结构体定义
struct data_source_s
{
    char name[DATA_MAX_NAME_LEN];
    int type; // 将存储如下枚举的值
    double min;
    double max;
};
typedef struct data_source_s data_source_t;

struct data_set_s
{
    char type[DATA_MAX_NAME_LEN];
    size_t ds_num;
    data_source_t *ds;
};
typedef struct data_set_s data_set_t;

// 为数据源类型定义一个枚举是一种好习惯
typedef enum {
    DS_TYPE_GAUGE = 0,
    DS_TYPE_DERIVE = 1,
    DS_TYPE_COUNTER = 2,
    DS_TYPE_ABSOLUTE = 3, // 根据需要添加其他类型
    // ... 其他类型
    DS_TYPE_UNKNOWN = -1
} data_source_type_enum_t;

// 这是一个模拟的 PluginService 和 vl 对象，以便代码可以演示
// 在您的实际代码中，您将使用真实的 PluginService
// void* 可以代表您的 vl.get() 返回的任何类型，这里仅为占位符
typedef struct ValueList {
    // 假设它包含一些数据，但对于硬编码 ds 本身不直接相关
    double values[1]; // 示例：假设它会提供一个值
} ValueList;

// 模拟 PluginService
void mock_plugin_service_write(const data_set_t* ds_ptr, ValueList* vl_ptr) {
    printf("模拟 PluginService::Instance().write 调用:\n");
    printf("  data_set.type: %s\n", ds_ptr->type);
    printf("  data_set.ds_num: %zu\n", ds_ptr->ds_num);
    if (ds_ptr->ds_num > 0 && ds_ptr->ds != NULL) {
        printf("  Data Source [0]:\n");
        printf("    name: %s\n", ds_ptr->ds[0].name);
        printf("    type (int): %d\n", ds_ptr->ds[0].type);
        printf("    min: %f\n", ds_ptr->ds[0].min);
        if (isnan(ds_ptr->ds[0].max)) {
            printf("    max: U (NAN)\n");
        } else {
            printf("    max: %f\n", ds_ptr->ds[0].max);
        }
        // 假设 vl_ptr 提供了要写入的实际值
        if (vl_ptr != NULL) {
             printf("    value from vl.get(): %f ( hypothetical)\n", vl_ptr->values[0]);
        }
    }
    printf("-----------------------------------------\n");
}


int main() {
    data_set_t ds = {0}; // 初始化所有成员为0或NULL

    // --- 开始硬编码 data_set_t ds ---

    // 1. 填充 data_set_t 的 'type' 字段
    // 对应 "cpu"
    strncpy(ds.type, "cpu", DATA_MAX_NAME_LEN -1);
    ds.type[DATA_MAX_NAME_LEN -1] = '\0'; // 确保字符串以null结尾

    // 2. 填充 data_set_t 的 'ds_num' 字段
    // "value:DERIVE:0:U" 是一个数据源定义
    ds.ds_num = 1;

    // 3. 为 data_source_t 数组分配内存
    // 因为 ds_num 是 1, 我们需要为1个 data_source_t 元素分配空间
    ds.ds = (data_source_t*)malloc(ds.ds_num * sizeof(data_source_t));
    if (ds.ds == NULL) {
        perror("为 ds.ds 分配内存失败");
        // 在实际应用中，这里应该有错误处理逻辑
        return 1;
    }

    // 4. 填充第一个 (也是唯一一个) data_source_t 元素 (ds.ds[0])
    // 对应 "value:DERIVE:0:U"

    // 4a. data_source_t.name 对应 "value"
    strncpy(ds.ds[0].name, "value", DATA_MAX_NAME_LEN -1);
    ds.ds[0].name[DATA_MAX_NAME_LEN -1] = '\0'; // 确保null结尾

    // 4b. data_source_t.type 对应 "DERIVE"
    // 我们将 "DERIVE" 映射到整数 DS_TYPE_DERIVE
    ds.ds[0].type = DS_TYPE_DERIVE;

    // 4c. data_source_t.min 对应 "0"
    ds.ds[0].min = 0.0;

    // 4d. data_source_t.max 对应 "U"
    // 'U' 通常表示未定义或无限制。一个常见的做法是使用 NAN (Not a Number)。
    // NAN 在 <math.h> 中定义。
    ds.ds[0].max = NAN;

    // --- 硬编码 data_set_t ds 完成 ---

    // 现在 ds 结构体已经按照 "cpu value:DERIVE:0:U" 的配置填充完毕
    // 您可以将其传递给您的 PluginService
    // 假设 vl 是一个已经准备好的 ValueList 指针或类似的东西
    ValueList vl_example;
    vl_example.values[0] = 123.45; // 假设这是从 vl.get() 得到的实际数据值

    // 调用您的函数 (这里用模拟函数替代)
    // PluginService::Instance().write(&ds, vl.get());
    mock_plugin_service_write(&ds, &vl_example);


    // 重要：释放动态分配的内存
    // 如果 ds.ds 是在栈上分配的单个 data_source_t, 则不需要 free。
    // 但由于您的结构体定义 ds 是一个指针，并且我们用 malloc 分配了它，所以需要 free。
    if (ds.ds != NULL) {
        free(ds.ds);
        ds.ds = NULL; // 良好的编程习惯，防止悬挂指针
    }

    return 0;
}
