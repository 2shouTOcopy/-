#pragma once

#include "ModuleBase.h"         // 假设定义了 CAbstractUserModule
#include "daemon/PluginService.h" // 假设定义了 PluginService 和相关类型/宏

#include <string>
#include <vector>   // 仅当某些辅助功能需要时，当前实现中 parseLine 不需要
#include <cstdint>  // For uint64_t, though gauge_t is likely double

// 假设 gauge_t, value_t, value_list_t, VALUE_LIST_INIT 来自 collectd 或 PluginService.h
// 如果 PluginService.h 没有包含它们，可能需要类似 #include "collectd.h" (或其C++等效物)

// 用于存储从 /proc/meminfo 解析出的数据
struct ParsedMemInfo {
    gauge_t mem_total = 0.0;
    gauge_t mem_used = 0.0;
    gauge_t mem_buffered = 0.0;
    gauge_t mem_cached = 0.0;
    gauge_t mem_free = 0.0;
    gauge_t mem_available = 0.0;
    gauge_t mem_slab_total = 0.0;
    gauge_t mem_slab_reclaimable = 0.0;
    gauge_t mem_slab_unreclaimable = 0.0;

    bool detailed_slab_info_present = false;
    bool mem_available_info_present = false;
};

class CMemoryModule final : public CAbstractUserModule {
public:
    CMemoryModule(); // 构造函数
    ~CMemoryModule() override = default; // 默认析构函数

    // 插件主读取函数，由 PluginService 调用
    // 假设 CAbstractUserModule 定义了 virtual int read() = 0; 或类似的
    int read() override;

private:
    // 解析 /proc/meminfo 文件
    bool parseMemInfo(ParsedMemInfo& data_out);

    // 辅助方法：解析 /proc/meminfo 中的单行
    bool parseLine(const std::string& line, const char* key_to_match, gauge_t& target_value_ref);
    
    // 提交单个指标数据
    void submitMetric(const std::string& type_instance_name, gauge_t value, const char* type_name = "memory");

    // 根据配置提交所有相关的内存指标
    void submitMemoryData(const ParsedMemInfo& parsed_data);

    // 配置项，类似于原 memory.c 中的全局静态变量
    bool m_values_absolute;
    bool m_values_percentage;
};

// 工厂函数声明
#ifdef __cplusplus
extern "C" {
#endif

CAbstractUserModule* CreateMemoryModule();
void DestroyMemoryModule(CAbstractUserModule* pUserModule);

#ifdef __cplusplus
}
#endif
