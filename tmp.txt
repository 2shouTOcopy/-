void TcpsServerManager::TaskWorker()
{
    int32_t sockfd = -1;
    int32_t maxfd  = -1;
    int32_t len    = 0;
    fd_set rdSet, wrSet;
    int32_t result = 0;
    struct timeval timeout;

    m_taskRun = true;

    while (!m_end)
    {
        if (m_reCreate || m_conning || !m_moduleEnable)
        {
            usleep(100000);
            continue;
        }

        if (m_taskLoopCallback)
        {
            m_taskLoopCallback();
        }

        timeout.tv_sec  = 0;
        timeout.tv_usec = MSG_RECV_SELECT_TIME * 1000;

        maxfd = -1;
        FD_ZERO(&rdSet);
        FD_ZERO(&wrSet);

        // 取出一条广播消息（如果你希望一次发完队列，这里可以改成 while 出队）
        TcpsMessage msg = {0};
        {
            std::lock_guard<std::mutex> lk(m_sendQueueMtx);
            if (!m_sendQueue.empty())
            {
                msg = m_sendQueue.front();
                m_sendQueue.pop();
            }
        }

        // ✅ 遍历“所有槽位”，不要在 for 条件里用 m_conns[i]
        const size_t n = m_conns.size(); // 建议 m_conns 预先 resize(MAX_CLIENT_NUM)
        for (size_t idx = 0; idx < n; ++idx)
        {
            if (!m_conns[idx])
                continue;

            LOGE("111:%zu\n", idx);

            sockfd = m_conns[idx]->GetSockFd();
            if (sockfd < 0)
                continue;

            if (msg.len > 0)
            {
                m_conns[idx]->InsertSendMsg(msg);
            }

            if (sockfd > maxfd)
                maxfd = sockfd;

            FD_SET(sockfd, &rdSet);

            if (!m_conns[idx]->IsSendQueueEmpty())
            {
                FD_SET(sockfd, &wrSet);
            }
        }

        if (maxfd < 0)
        {
            usleep(MSG_RECV_SELECT_TIME * 1000);
            continue;
        }

        result = select(maxfd + 1, &rdSet, &wrSet, nullptr, &timeout);

        if (result > 0)
        {
            for (size_t idx = 0; idx < n; ++idx)
            {
                if (!m_conns[idx])
                    continue;

                LOGE("222:%zu\n", idx);

                sockfd = m_conns[idx]->GetSockFd();
                if (sockfd < 0)
                    continue;

                if (FD_ISSET(sockfd, &rdSet))
                {
                    // 如果 Recv 可能阻塞，这里会“卡住”
                    len = m_conns[idx]->Recv();
                    if (len <= 0)
                    {
                        LOGE("tcp client recv ret %d, [%zu], sockfd=%d\r\n", len, idx, sockfd);
                        m_conns[idx]->Close();
                        m_conns[idx].reset();
                        continue;
                    }
                }

                if (FD_ISSET(sockfd, &wrSet))
                {
                    LOGE("333:%zu\n", idx);
                    len = m_conns[idx]->Send();
                    if (len < 0 && (errno != EINTR && errno != EAGAIN))
                    {
                        LOGE("tcp client send error, [%zu]sockfd=%d\r\n", idx, sockfd);
                        m_conns[idx]->Close();
                        m_conns[idx].reset();
                        continue;
                    }
                }
            }
        }
        else if (result < 0)
        {
            // select 出错时，也不要用 “&& m_conns[i]” 这种写法
            for (size_t idx = 0; idx < n; ++idx)
            {
                if (!m_conns[idx])
                    continue;

                LOGE("444:%zu\n", idx);

                sockfd = m_conns[idx]->GetSockFd();
                if (sockfd >= 0 && FD_ISSET(sockfd, &rdSet))
                {
                    LOGE("tcp client select error, [%zu]sockfd=%d\r\n", idx, sockfd);
                    m_conns[idx]->Close();
                    m_conns[idx].reset();
                }
            }
        }
        // result == 0: timeout，啥也不做，下一轮
    }

    m_taskRun = false;
}