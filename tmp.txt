#include <string>
#include <ctime>
#include <cstdlib> // For system()
#include <iostream> // For logging placeholders like INFO, ERROR

// --- 假设的日志宏和配置管理器，用于编译和展示 ---
#define INFO(format, ...)  printf("[INFO] " format "\n", ##__VA_ARGS__)
#define ERROR(format, ...) fprintf(stderr, "[ERROR] " format "\n", ##__VA_ARGS__)

class ConfigManager {
public:
    static ConfigManager& Instance() {
        static ConfigManager instance;
        return instance;
    }
    std::string GetGlobalOption(const std::string& key) {
        if (key == "BaseDir") {
            return "/mnt/data/collect/var/"; // 模拟您的情况
        }
        return "";
    }
};
// --- 假设的服务 ---
class PluginService {
public:
    static PluginService& Instance() {
        static PluginService instance;
        return instance;
    }
    void readAll() { /* ... */ }
    void flushAll() { /* ... */ }
};
// --- 以上为辅助代码 ---


// --- 修改后的核心函数 ---
void* CollectDaemon_flushThread(void* /*arg*/)
{
    INFO("Manual flush: start.");

    PluginService::Instance().readAll();
    PluginService::Instance().flushAll();

    std::string baseDir = ConfigManager::Instance().GetGlobalOption("BaseDir");
    if (baseDir.empty()) {
        ERROR("BaseDir is not configured.");
        return nullptr;
    }

    // 1. 规范化路径：移除尾部的斜杠'/'，使路径处理更可预测
    std::string cleanBaseDir = baseDir;
    while (!cleanBaseDir.empty() && cleanBaseDir.back() == '/') {
        cleanBaseDir.pop_back();
    }

    if (cleanBaseDir.empty()) {
        ERROR("BaseDir becomes empty after cleaning: %s", baseDir.c_str());
        return nullptr;
    }

    // 2. 安全地提取父目录和目标目录名
    size_t lastSlashPos = cleanBaseDir.find_last_of('/');
    if (lastSlashPos == std::string::npos) {
        ERROR("Invalid BaseDir format. Cannot find parent directory: %s", baseDir.c_str());
        return nullptr;
    }

    std::string parentDir = cleanBaseDir.substr(0, lastSlashPos);
    std::string targetDirName = cleanBaseDir.substr(lastSlashPos + 1);

    // 如果parentDir为空，说明BaseDir在根目录，例如 "/var"。此时父目录就是 "/"
    if (parentDir.empty()) {
        parentDir = "/";
    }

    // 3. 构建压缩包路径和名称
    time_t now = time(nullptr);
    char timeStr[20];
    strftime(timeStr, sizeof(timeStr), "%Y%m%d_%H%M%S", localtime(&now));
    
    std::string archivePath = parentDir + "/collect_data_" + timeStr + ".tar.gz";
    
    // 4. 构建健壮的tar命令
    // 使用 -C 选项，先切换到 parentDir，然后对 targetDirName 进行打包。
    // 这样做的好处是压缩包里的路径会是 "var/..." 而不是一长串绝对路径。
    std::string cmd = "tar -zcf " + archivePath + " -C " + parentDir + " " + targetDirName;
    
    INFO("Executing compression command: %s", cmd.c_str());
    int ret = system(cmd.c_str());
    
    if (ret != 0) {
        // system() 的返回值需要通过 WIFEXITED 和 WEXITSTATUS 来正确解码
        if (WIFEXITED(ret)) {
            ERROR("Failed to compress BaseDir. Command exited with status %d: %s", WEXITSTATUS(ret), cmd.c_str());
        } else {
            ERROR("Failed to compress BaseDir. Command terminated abnormally: %s", cmd.c_str());
        }
    } else {
        INFO("Successfully compressed BaseDir to: %s", archivePath.c_str());
    }

    INFO("Manual flush: done.");
    return nullptr;
}
