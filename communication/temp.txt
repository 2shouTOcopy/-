Modbus：线程改造（完整替换）

把你给的 ThreadProcessScheduledTrans 替换为下面版本（接入引擎 + simple_fifo 适配 + 保留绑核/线程名 + 统一配置）。

extern "C" {
uint64_t get_up_time();              // 毫秒
void thread_set_name(const char* n);
void thread_bind_cpu(int cpu);
}

static void _sleep_us(uint32_t us) { usleep(us); }

// 注：log宏按你项目实际替换，这里直接用 LOGE
static void _loge(const char* fmt, ...) {
    va_list ap; va_start(ap, fmt);
    vfprintf(stderr, fmt, ap);
    va_end(ap);
}

void *ThreadProcessScheduledTrans(IN void* argv)
{
    CModbusTransModule* pUserModule = (CModbusTransModule*)argv;
    if (!pUserModule) return nullptr;

    // 线程名/绑核（保留）
    char szGetString[64] = {0};
    snprintf(szGetString, sizeof(szGetString), "%s_mbs", SCHEDULED_NAME);
    thread_set_name(szGetString);
#ifndef ASAN_SUPPORT
    thread_bind_cpu(1);
#endif

    // 触发源
    auto trig = mvsc_idr_app::ITriggerSource::getComponent();
    if (trig == nullptr) return nullptr;

    // 队列适配：simple_fifo
    SimpleFifoAdapter qadp(&(pUserModule->m_struScheduledQueue));

    // 编码器
    EncoderStatusAdapter encoder;

    // 发送函数
    auto sendFn = [&](const scheduled_fifo_param& p) {
        if (p.len <= sizeof(p.buf)) {
            modbus_send_result((char*)p.buf, (int)p.len);
        }
    };

    // 引擎上下文
    OutputContext ctx{};
    ctx.queue = &qadp;
    ctx.trig  = trig;
    ctx.encoder = &encoder;
    ctx.nowMs = &get_up_time;
    ctx.sleepUs = &_sleep_us;
    ctx.send = sendFn;
    ctx.mode = OutputMode::kImmediate;      // 初始值，循环里会更新
    ctx.scheduledIntervalMs = 0;            // 循环里会更新
    ctx.ngText = SCHEDULED_TRANS_NG_STRING; // 与现实现一致（仅定时模式用）
    ctx.loge = _loge;

    OutputModeEngine engine(ctx);

    while (1) {
        // 只读配置（全局）
        int mEnable = 0;
        int outMode = 0;            // 0/1/2
        int intervalMs = 0;

        try {
            mEnable    = pUserModule->GetParamManagePtr()->GetParam<int>(MODBUS_MOUDLE_ENABLE);
            outMode    = pUserModule->GetParamManagePtr()->GetParam<int>(PM_OUTPUT_MODE);
            intervalMs = pUserModule->GetParamManagePtr()->GetParam<int>(PM_SCHEDULED_TRANS_TIME); // 毫秒
        } catch (const std::invalid_argument&) {
            // 保持默认0
        }

        if (!mEnable) {
            // 模块关闭：清空队列，按原逻辑sleep
            sfifo_drain(&(pUserModule->m_struScheduledQueue));
            _sleep_us(MAX_COMMUNICATION_USLEEP_TIME);
            continue;
        }

        // 更新引擎配置
        OutputMode mode = OutputMode::kImmediate;
        if      (outMode == 1) mode = OutputMode::kTimed;
        else if (outMode == 2) mode = OutputMode::kEncoder;
        engine.setConfig(mode, (uint32_t)intervalMs);

        // 主循环步进
        engine.tick();

        _sleep_us(MAX_COMMUNICATION_USLEEP_TIME);
    }

    return nullptr;
}

// 启动线程（保持原调用）
/*
nRet = thread_spawn_ex(&m_nThreadScheduledTrans, 0, SCHED_POLICY_RR,
                       SCHED_PRI_HIGH_50, 10 * 1024,
                       ThreadProcessScheduledTrans, this);
*/

行为对齐点：
	•	定时模式：与原先一致（新帧→等间隔→队列空则发 NG，成功则发队列第一条；然后把该帧记为已处理）。
	•	编码器模式：新帧→等编码器=1→若队列有数据则发；若队列空仅 LOGE，不发 NG；无论是否发送，都将该帧记为已处理，保证“一帧只尝试一次”，不会反复刷日志，也避免同帧晚到的数据被再次发送。
	•	单位全部毫秒；sleep 仍为 5ms 步进（与原代码一致）。
	•	触发模式门控：定时/编码器模式只有在 TRIGGER_MODE_PARAM != 0 时才工作；立即模式无该限制。

⸻

TCP：改造片段（改队列为统一结构 + 接线）

1）成员改造

// 原来：std::queue<TcpsMessage> m_shchedSendQueue;
#include <deque>
std::deque<scheduled_fifo_param> m_shchedSendQueue; // 统一结构
std::mutex m_shchedSendQueueMtx;
DequeAdapter* m_qAdapter = nullptr;
OutputModeEngine* m_engine = nullptr;

2）入队改造（满则丢旧）

void CTcpsMessage::EnqueueScheduled(const uint8_t* data, uint32_t len) {
    scheduled_fifo_param p{};
    p.len = std::min<uint32_t>(len, MAX_SCHEDULED_PAYLOAD_LEN);
    std::memcpy(p.buf, data, p.len);

    if (!m_qAdapter) m_qAdapter = new DequeAdapter(&m_shchedSendQueue, &m_shchedSendQueueMtx);
    m_qAdapter->push_drop_old(p);
}

3）初始化引擎（在构造或 Init 中调用）

extern "C" uint64_t get_up_time();
static void _sleep_us(uint32_t us){ usleep(us); }

void CTcpsMessage::InitOutputEngine() {
    if (!m_qAdapter) m_qAdapter = new DequeAdapter(&m_shchedSendQueue, &m_shchedSendQueueMtx);

    auto trig = mvsc_idr_app::ITriggerSource::getComponent();
    static EncoderStatusAdapter encoder; // 如 TCP 也需要编码器

    auto sendFn = [this](const scheduled_fifo_param& p){
        // 复用原有发送：将统一结构转成 TcpsMessage 再入发送服务
        TcpsMessage msg{};
        size_t n = std::min(sizeof(msg.buf), (size_t)p.len);
        std::memcpy(msg.buf, p.buf, n);
        msg.len = (int)n;
        this->m_msgServer.InsertSendMsg(msg);
    };

    auto loge = [&](const char* fmt, ...){
        va_list ap; va_start(ap, fmt);
        vfprintf(stderr, fmt, ap);
        va_end(ap);
    };

    OutputContext ctx{};
    ctx.queue = m_qAdapter;
    ctx.trig  = trig;
    ctx.encoder = &encoder;         // 若 TCP 不需要编码器，可置空
    ctx.nowMs = &get_up_time;       // 毫秒
    ctx.sleepUs = &_sleep_us;
    ctx.send = sendFn;
    ctx.mode = OutputMode::kImmediate;
    ctx.scheduledIntervalMs = 0;
    ctx.ngText = SCHEDULED_TRANS_NG_STRING;
    ctx.loge = loge;

    m_engine = new OutputModeEngine(ctx);
}

4）线程轮询替换（原 DispatchQueuedMessages()）

void CTcpsMessage::DispatchQueuedMessages()
{
    // 读取全局配置
    int outMode = 0;
    int intervalMs = 0;
    try {
        outMode    = GetParamManagePtr()->GetParam<int>(PM_OUTPUT_MODE);
        intervalMs = GetParamManagePtr()->GetParam<int>(PM_SCHEDULED_TRANS_TIME);
    } catch (const std::invalid_argument&) {}

    OutputMode mode = OutputMode::kImmediate;
    if      (outMode == 1) mode = OutputMode::kTimed;
    else if (outMode == 2) mode = OutputMode::kEncoder;

    if (m_engine) {
        m_engine->setConfig(mode, (uint32_t)intervalMs);
        m_engine->tick();
        return;
    }

    // 兜底：引擎未初始化则批量直发
    std::deque<scheduled_fifo_param> local;
    {
        std::lock_guard<std::mutex> lk(m_shchedSendQueueMtx);
        if (!m_shchedSendQueue.empty()) local.swap(m_shchedSendQueue);
    }
    for (auto& p : local) {
        TcpsMessage msg{};
        size_t n = std::min(sizeof(msg.buf), (size_t)p.len);
        std::memcpy(msg.buf, p.buf, n);
        msg.len = (int)n;
        m_msgServer.InsertSendMsg(msg);
    }
}

TCP 的线程模型不变：外层线程仍按你原来频率轮询 DispatchQueuedMessages() 即可。

⸻

关键行为对齐与差异说明
	•	统一结构体：所有算子待发元素统一为 scheduled_fifo_param，队列满丢旧。
	•	单位：TRIGGER_IMG_TIME 与 get_up_time() 毫秒；定时间隔 PM_SCHEDULED_TRANS_TIME 毫秒。
	•	触发门控：kTimed/kEncoder 仅在 TRIGGER_MODE_PARAM != 0 生效；kImmediate 不受限。
	•	定时模式：到时且队列空 → 发 NG（与原实现一致）。
	•	编码器模式：编码器=1 且队列空 → 仅 LOGE，不发 NG；视为已处理该帧（更新 lastTrigCount_），避免重复日志与后续“同帧晚到数据”被再次发送，满足“每帧只尝试一次”。
	•	失败处理：触发源读取失败/编码器缺失 → 仅日志 + 5ms sleep 继续循环。
	•	性能：仍以 5ms 步进；立即模式批量清空队列；其余模式只消费一条或不消费。
	•	可扩展：后续新增模式只需在 OutputModeEngine 里加一个 stepXxx_()，setConfig() 切到新枚举即可，算子侧无需改动。

⸻

如果你要我再把 UDP/Modbus/TCP 三个模块的入队接口统一成一个 EnqueueScheduled() 并给出完整类文件（含头/源拆分、宏与你们日志体系一致），我可以直接补齐；或者把 output_mode.* 折叠到你现有公共库，避免新增文件名。
